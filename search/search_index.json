{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to NUS CG3207 - Computer Architecture","text":"<p>Welcome to CG3207! In this repository, you will find the manuals for each of the 4 lab exercises you will complete for this course, as well as instructions on how to set up the tools you'll need.</p> <p>Labs for this course are generally free and easy. Physical attendance is recommended, but not necessary EXCEPT FOR ASSESSMENTS. There are 4 lab assignments in total, each of which will first be introduced in a briefing, and then assessed in a subsequent (not necessarily the next) week. At least one member of the teaching team will always be present in the lab during lab sessions to assist with any doubts you have.</p> <p>Check NUSMods for the lab venue corresponding to your lab slot. </p>"},{"location":"#intended-learning-outcomes-labs","title":"Intended learning outcomes (labs)","text":"<p>In the lab component of this course, you will put into practice the concepts learned in lecture (as well as some you explore on your own), and see them come to life.</p> <p>You will learn:</p> <ul> <li>The RISC-V architecture and assembly language.</li> <li>How to build your very own CPU which can execute real RISC-V programs.</li> <li>Advanced CPU design tricks to improve performance.</li> </ul>"},{"location":"#first-steps","title":"First steps","text":"<p>To make the most of the labs, we recommend doing some reading before you come for your first session.</p> <ol> <li> <p>First, the page on how to use this website. Pay special attention to the section on \"How to get help\", as it is very important.</p> </li> <li> <p>Next, the prerequisites for the lab. If you have any concerns with these prerequisites, please approach the teaching team as early as possible. The background knowledge outlined in this page is critical for you to do well in this course.</p> </li> <li> <p>Make sure you read Getting to know your Nexys 4 and install Vivado on your personal computer as soon as possible. If you do not have access to a Windows or Linux (preferred) PC, you should try your best to get/borrow one for this course. Vivado does work in Parallels Desktop on a Mac, but this is an expensive piece of software, and not entirely a supported configuration.</p> </li> <li> <p>Finally, choose an architecture that you want to work with for the labs. You may choose between RISC-V (recommended), or ARM (deprecated, not well-supported by teaching team). This might also be a good time to form teams of two to three people for labs 2, 3, and 4. Note that Lab 1 will be an individual exercise, and you will not be assessed as a team - though, of course, we encourage you to work together (academically honestly, of course - no copying or direct sharing of work, please).</p> </li> </ol>"},{"location":"#lab-outline","title":"Lab outline","text":"Lab Description Marks Remarks 1 Familiarisation with HDL/FPGA and Assembly Language.  Omae wa mou shindeiru. 10 Individual exercise 2 Basic CPU design.    All your base are belong to us. 30 Teams of 2 or 3 students 3 ALU Design.   Billions of blue blistering barnacles. 20+5$ Teams of 2 or 3 students 4 Advanced CPU design.     It was the best of times, it was the worst of times. 15+10$ Teams of 2 or 3 students Total 90 = 45% of the module grade <p>The lab assignment repository contains all the files you need to download. Some other useful resources can also be found using the menu on the left of this page.</p>"},{"location":"#lab-schedule","title":"Lab Schedule","text":"Week Monday Lab Date (18:00-21:00) Friday Lab Date (09:00-12:00) Activity 4 1 Sep 2025 5 Sep 2025 Lab 1 Intro 5 8 Sep 2025 12 Sep 2025 Lab 1 Demo, Lab 2 Intro 6 15 Sep 2025 19 Sep 2025 Lab 2 Consultation Recess 22 Sep 2025 26 Sep 2025 No Lab Session 7 29 Sep 2025 3 Oct 2025 Lab 2 Demo, Lab 3 Intro 8 6 Oct 2025 10 Oct 2025 Lab 3 Consultation 9 13 Oct 2025 17 Oct 2025 Lab 3 Demo, Lab 4 Intro 10 20 Oct 2025 24 Oct 2025 No Lab - Deepavali 11 27 Oct 2025 31 Oct 2025 Lab 4 Consultation 12 3 Nov 2025 7 Nov 2025 Lab 4 Demo"},{"location":"#license","title":"License","text":"<p>NUS CG3207 Lab Assignments \u00a9 2025 by NUS CG3207 Team is licensed under CC BY-NC-SA 4.0 </p>"},{"location":"ARM/arm_memmap/","title":"ARM Memory Map","text":""},{"location":"ARM/arm_memmap/#memory-map-of-our-arm-processor","title":"Memory Map of OUR* ARM Processor","text":"<p>*This memory map is not compliant with any standards/recommendations. It is just the choice/design of the CG3207 lecturer.</p> Address Attributes DESCRIPTION 0x00000000 to 0x000001FC RO (Read Only) Instruction memory (ROM). 128 words. Word addressable - only multiples of 4 are valid addresses. This might cause warnings about 2 unused bits, but that's ok. 0x00000200 to 0x000003FC RO Data (Constant) memory (ROM). 128 words. Word addressable - only multiples of 4 are valid addresses. 0x00000800 to 0x000009FC RW (Read/Write) Data (Variable) memory (RAM). 128 words. Word addressable - only multiples of 4 are valid addresses. 0x00000A00 to 0x00000BFC - Unused / unmapped. 0x00000C00 WO (Write Only) LED[15:8]. Only the least significant 8 bits written to this location are used. LED[7] is used to show the divided clock. LED[6:0] shows PC[8:2]. PC[1:0] will always be 0 and hence not shown. 0x00000C04 RO DIP switches. Only the least significant 16 bits read from this location are valid, corresponding to SW[15:0]. 0x00000C08 RO PushButton switches. [2:0] \u2192\u00a0\u00a0BTNL, BTNC, BTNR. Only the least significant 3 bits read from this location are valid.\u00a0BTND is used as RESET and\u00a0BTNU is used as PAUSE. 0x00000C0C RW UART Console (both in and out). UART Settings: Baud Rate 115200. 8-bit. No Parity. 1 Stop bit. More details are given below. Only the least significant 8 bits in this location can be read/written. UART and RealTerm page has more details, as well as a short tutorial on RealTerm, a very good console application. 0x00000C10 RO CONSOLE_IN_valid. 0x00000C14 RO CONSOLE_OUT_ready. 0x00000C18 WO 7-Segment LED display. The data written to this location will appear as an 8-digit hexadecimal number on the display. For the Basys 3 board, the two half-words will keep displaying in alternation. <p>Table 1: Memory map summary</p>"},{"location":"ARM/arm_memmap/#endianness","title":"Endianness","text":"<p>The instruction and data memory are WORD addressable (NOT byte-addressable) for our labs. =&gt; Endianness doesn't matter for our hardware. However, the Hex2ROM converter tool assumes a little-endian format by default. Endianness matters only when each byte in the memory has an address, but we read/write one word (4 bytes) in one go. For example, if we store two words 0xABCD1234 and 0xEF567890 in the memory starting at the address 0x00000000, the two words will be stored at word addresses 0x00000000 and 0x00000004 respectively. In a system with a little-endian processor, the byte address 0x00000000 will have the content 0x34, byte address 0x00000001 will have the content 0x12, byte address 0x00000003 will have the content 0xAB, byte address 0x00000004 will have the content 0x90, byte address 0x00000007 will have the content 0xEF. In CG3207 labs, we use a memory that cannot deal with byte addresses such as 0x00000001 and 0x00000002. We can only send word addresses (addresses which are multiples of 4), i.e., like 0x00000000 and 0x00000004, and get the corresponding 32-bit contents. Hence, for our hardware, endianness doesn't matter. However, we need to maintain consistency between our selection in Keil and the Hex2ROM converter tool.</p>"},{"location":"ARM/arm_programming/","title":"ARM Programming Guide","text":"<p>Keil MDK is an IDE for ARM assembly/C programming and simulation. The lite version (with 32K code/debug limit and nag-screen) is available for free. You can download it on ARM website.</p> <p>Note : The latest version is Keil MDK 5. However, you will need to install the legacy support for ARM7 which we are going to use in this module. It is easier to go with Keil MDK 4.</p> <p>We will be using Keil MDK 4 as it comes with a built in simulator* for many ARM based cores. This allows you to test your programs before you run it on the processor YOU made. We will be using ARM7 (a microarchitecture executing ARMv3 instruction set, not to be confused with ARMv7A/M/R instruction set architecture) in this module, which is somewhat similar to the ARM Cortex M3/M4 you used in LPC1769/STM32L4 (executing ARMv7M) at an assembly level but very different at the machine language level. There are some very significant differences though, which we will see as we go along.</p> <p>*Note that the STM32 / LPCXpresso IDE you used in EE2028/CG2028/EE2024 do not have a simulator - to test a program, you needed a microprocessor board.</p>"},{"location":"ARM/arm_programming/#creating-a-project-and-basic-settings","title":"Creating a Project and Basic Settings","text":"<ul> <li>To create a new project, Project &gt; New uVision project. Select a location (preferably an empty folder) and give a name (which will be the same as the name of the Hex file generated by the IDE, so remember the name you gave and the location).</li> <li>You will get a device selection screen. Expand ARM and choose ARM7 (Little Endian).</li> <li>On the project pane on the left, expand 'Target 1' &gt; right-click on Source Group 1. Select 'Add files to Group Source Group 1'.</li> <li>In the file selection window that comes up, in the drop-down list, change 'Files of type' to 'Asm Source file (*.s*, *.src, *.a*)'. Browse to the folder containing the assembly language source (.s) file and click 'Add'. Click 'Close' to dismiss the window (it won't disappear even after you select a file).</li> <li>Use this sample assembly language program -\u00a0ARM_sample.s. Please read the instructions in the comments carefully.\u00a0The example code will produce this error when you execute the instruction in line 39 (line 30 in the older version) - error 65: access violation at 0x00000804 : no 'write' permission. However, this does not cause any problem in real hardware - say, if you try this code on the processor you will be designing in Lab 2. Why?</li> <li>Screenshots illustrating settings are given below. To bring up the window :\u00a0Project -&gt; Options for Target 'Target 1'. Note that the correct window might come up only on the second try - thanks to the wonderful (sarcasm intended) Keil UI.</li> <li>Use\u00a0this file MMIO.ini in\u00a0Project -&gt; Options for Target -&gt; Debug -&gt; Initialisation file (see the screenshot below).</li> </ul> <p>*See bullet 7 above</p> <p></p> <p></p> <p>Figure 1(a)-1(f) : Project &gt; Options for Target '' <ul> <li>Please note that syntax highlighting might not work properly for some keywords.</li> </ul>"},{"location":"ARM/arm_programming/#programming-instructions","title":"Programming Instructions","text":"<ul> <li>Note that the assembler directives in Keil MDK are different from LPCXpresso IDE/GCC toolchain.\u00a0<ul> <li>For example, instead of\u00a0.word, Keil uses\u00a0DCD\u00a0directive.\u00a0</li> <li>The assembler directives can be found\u00a0here.\u00a0</li> <li>You might be particularly interested in DCD (.word), DSB (store bytes, for strings), SPACE (.lcomm), EQU (.equ).\u00a0</li> <li>Labels do not have a ':' following them.</li> </ul> </li> <li>PC relative adressing mode (LDR Rd, LABEL)\u00a0is identical to offset mode, where the base register is implicitly R15/PC (LDR Rd,\u00a0[R15, #offset]). The offset is calculated automatically by the assembler, as the assembler knows the address corresponding to LABEL. Please note that in ARMv3, reading R15/PC returns the current PC+8.\u00a0</li> <li>Instructions with R15/PC as an implicit or explicit source operand\u00a0(for example, PC relative load/source, Data processing instructions with PC as a source operand, Branch) can only use PC+8 value. However, if the R15/PC is specified as a destination (implicity or explicity), the result is written as such to R15/PC.\u00a0\u00a0</li> <li>DO NOT use pseudo-instructions.\u00a0<ul> <li>Instead of the pseudo-instruction\u00a0LDR\u00a0\u00a0R2, =variable1; use\u00a0LDR R2, variable1_addr\u00a0and\u00a0variable1_addr DCD variable1.\u00a0</li> <li>This will allow us to have control over where exactly\u00a0variable1_addr is stored in the memory, which\u00a0will make things easier when we insert our program into the Instruction (code) and Data (constant) ROMs created in the FPGA (in Lab 2).</li> <li>Keil/ARM assembler supports pseudo-instructions, but we just avoid it for the reason mentioned above.</li> </ul> </li> <li>You can refer to\u00a0ARM Architecture Reference Manual.pdf\u00a0to see ARMv3 instruction set architecture.</li> </ul>"},{"location":"ARM/arm_programming/#debugging-instructions","title":"Debugging Instructions","text":"<ul> <li> <p>To start a debug session, go to Debug &gt; Start/Stop debugging session. Debugging is done similar to how it is done in almost all IDEs. You can the see instruction in Hex, inspect register and memory values etc.  </p> </li> <li> <p>Make sure you do a 'Rebuild All' before you start a debug session ()\u00a0every time you make some changes in code. The IDE will not even prompt you to rebuild your code. It will continue using the binary from your last build, but the code displayed is the latest. This behavior it baffling, to say the least. To avoid it, always Rebuild All before starting a debug session.  </p> </li> <li> <p>Also note that when you do a CPU reset in the simulator (), the RAM (memory storing variables) in the simulator might not get reset.  </p> </li> <li> <p>Use memory windows to see the memory contents.\u00a0. You can click and edit the memory (only regions with read-write permission) if you want to manually change memory values during debugging.</p> </li> </ul>"},{"location":"ARM/arm_programming/#converting-hex-to-rom-initialization-code","title":"Converting .hex to ROM Initialization Code","text":"<p>Open the\u00a0Hex2ROM program (requires VS 2012 Redistributable)\u00a0and navigate to the .hex file for your project, generated by Keil MDK. The program converts the .hex file into a format which can be pasted into Wrapper.vhd/v (for Lab 2) or the ROMs for Lab 1. The format to be pasted is written into the clipboard as well as to a .vhd/v file having the same name as the .hex file.\u00a0 </p>"},{"location":"asst_manuals/Asst_01/Asst_01/","title":"Assignment 1: Familiarisation with Assembly Language and HDL/FPGA","text":"<p>Info</p> <p>Assignment 1 consists of 2 tasks, worth 5 points each, for a total of 10 points.</p> <p>Assignment 1 is an individual exercise. You will work in groups for later labs, but this one must be completed, submitted and demonstrated individually.</p>"},{"location":"asst_manuals/Asst_01/Asst_01/#introduction","title":"Introduction","text":"<p>This assignment is designed to test your prerequisite knowledge for smooth completion of this course. It will walk through some basics of desigining for FPGA hardware,  writing RISC-V code, and how to use your RISC-V code in an FPGA design.</p> <p>It is imperative to put in effort and try your best for this assignment. It may take an amount of effort that is quite disproportionately large, compared to the impact on your grade. This is normal. This assignment is designed to prepare you for the later ones, so that you can spend time debugging your design, instead of debugging your knowledge. </p>"},{"location":"asst_manuals/Asst_01/Asst_01/#task-0-getting-familiar-with-fpgas-0-points","title":"Task 0: Getting familiar with FPGAs [0 points]","text":"<p>To comfortably complete Assignment 1 (and 2 and 3 and 4, for that matter), solid familiarity with the FPGA design toolchain is required. Having taken, and understood (at least most of) EE2026 or CS2100DE is sufficient for this level of familiarity.</p> <p>If you are not confident of your Vivado-wrangling and FPGA-whispering capabilities, you should go to the CS2100DE website and attempt Lab 1 through Lab 4.</p> <p>If you have already read through, and followed the instructions in Lab Prerequisites, as you should have done, then congratulations - you are ready for the tasks ahead! If not, now is the time to do so.</p> <p>This task is not graded, but necessary to be able to complete the assignments meaningfully. Please do not take it lightly.</p>"},{"location":"asst_manuals/Asst_01/Asst_01/#task-1-assembly-simulation-5-points","title":"Task 1: Assembly simulation [5 points]","text":""},{"location":"asst_manuals/Asst_01/Asst_01/#task-overview","title":"Task overview","text":"<p>The goal of this task is to get familiar with the RISC-V assembler/simulator or ARM assembler/simulator by simulating a sample program. We will simulate a system with memory-mapped input/output (MMIO).</p> <p>We assume that the LEDs on this system are mapped to address <code>0xFFFF0060</code>. This means that when we write to this memory address using <code>sw</code>, the least significant 16 bits of whatever data we write to this address is shown on the LEDs. For example, if we write <code>0xF0F0</code>, the first four LEDs from the left will be lit, then the next four will be unlit, the next four lit, and the last four unlit.</p> <p>Similarly, we assume that the DIP switches are mapped to address <code>0xFFFF0064</code>. This means that when we read data from this memory address using <code>lw</code>, the least significant 16 bits of data read will correspond to the state of the switches. For example, if the switches are alternating between on (up) and off (down), with the first switch from the left being on, the data read will be <code>0xAAAA</code>.</p>"},{"location":"asst_manuals/Asst_01/Asst_01/#task-instructions","title":"Task instructions","text":"<p>In this task, we will simulate the user providing some input to the switches, and observe the provided assembly program display said input on the LEDs. The first step, of course, is to download the RISC-V assembly sample program or the ARM assembly sample program. Then, we can open our sample file in RARS or Keil MDK and start simulating.</p> RISC-V (RARS)ARM (Keil MDK) <p>Refer to Lab 4 from CS2100DE for some help on how to open a RISC-V assembly file in RARS. The guide is written for a different sample program, but the steps to open, assemble and run the code are identical.</p> <p>Warning</p> <p>Remember to set the memory configuration correctly - from \"Settings\" -&gt; \"Memory Configuration\", choose \"Default\". Setting this correctly is very important - our simulation for this assignment depends on this memory configuration being selected, and our CPU design later will also assume this memory configuration.</p> <p>Once you have assembled and begun to run the RISC-V code line-by-line, before executing line 48, simulate changing the input on the switches by modifying the memory at the address mapped to the DIP switches (<code>0xFFFF0064</code>). Then, continue running the code, including lines 48 and 49, one line at a time, until the memory at the address for the LEDs (<code>0xFFFF0060</code>) changes to reflect the new data. </p> <p></p> <p>Screenshot of addresses in RARS</p> <p>Refer to the ARM Programming Guide for instructions on how to set up and use Keil MDK. </p> <p>Once you have assembled and begun to run the ARM code line by line, before executing line 23, simulate changing the input on the switches by modifying the memory at the address mapped to the DIP switches (<code>0xC04</code>). Then continue running the code, including lines 23 and 24, one line at a time, until the memory at the address for the LEDs (<code>0xC00</code>) changes to reflect the new data.</p> <p></p> <p>Screenshot of addresses in Keil MDK</p> <p>For the assessment, you must be able to demonstrate everything you just did in front of your assessor. You must also understand every line of the sample assembly program, as you may be quizzed on what a particular line (or set of lines) does.</p> <p>Finally, dump the instruction and data memories. Click the \"Dump Memory\" button in RARS to do this. We need to dump the \"text\" (instruction) and \"data\" sections, using the \"Hexadecimal Text\" option, and finally choosing to \"Dump to File...\". Name these with .mem extension and keep them in a safe place to use in the next task.</p>"},{"location":"asst_manuals/Asst_01/Asst_01/#optional-but-recommended","title":"Optional but Recommended","text":"<p>Simulate a 'Hello World' Program.  There are 2 versions provided - </p> <ul> <li>HelloWorld that doesn't use subroutines and can be done using instructions implemented in Assignment 2, and</li> <li>HelloWorld_jal_jalr that uses subroutines and requires full <code>jal</code> and <code>jalr</code> support.</li> </ul> <p>Since we are using a simulator now and isn't worried about processor capabilities, you can simulate either or both. Read the UART peripheral details to understand the 4 registers involved. To simulate it, you need to go to Tools&gt;Keyboard and Display MMIO simulator, and the 'Connect to Program'. The following screenshot will be handy.</p> <p> Note that if you are single-stepping, you need to give the keyboard inputs at the appropriate time - after the previous keypress has been ready by the program - there is no buffer to store characters if you send them at a rate faster than the program can consume it.</p>"},{"location":"asst_manuals/Asst_01/Asst_01/#task-2-basic-hdl-simulation-and-implementation-5-points","title":"Task 2: Basic HDL simulation and implementation [5 points]","text":"<p>In this task, we will implement a simple hardware demo, that reads data from two Read-Only Memories (ROMs) and displays them on the seven-segment display on the FPGA. Note that we are not (yet) building a CPU, or anything that actually executes the instructions, so what instructions we use is somewhat irrelevant.</p>"},{"location":"asst_manuals/Asst_01/Asst_01/#design-specification","title":"Design specification","text":"<p>The system we will implement looks like this:</p> <p></p> <p>A block diagram of the system we want to implement</p> <p><code>IROM</code> (<code>INSTR_MEM</code> in the figure above) and <code>DMEM</code> (<code>DATA_CONST_MEM</code> in the figure above) are ROMs with 128 words each. We will use RARS to dump our assembly program into these ROMs, so <code>IROM</code> will hold the instructions of the assembly program (in machine code, of course), while <code>DMEM</code> will hold the constants and initialised variables we declare in the program. In later assignments, the <code>DMEM</code> hardware we implement will be writeable, but for now, we assume that it is not, and hence a 'ROM'. The ROMs are both combinational logic and do not need clocking. Both ROMs are only word-addressable, not byte-addressable.</p> <p>The <code>Clock_Enable</code> block generates an <code>enable</code> signal, to be used in tandem with the system clock <code>clk</code>. A module using this clock enable should, at every edge of <code>clk</code>, check if <code>enable</code> is high, and only be enabled if it is. </p> <p><code>Clock_Enable</code> takes in the upper and center push buttons as inputs, and uses them as follows:</p> <ol> <li> <p>If <code>btnU</code> is pressed, <code>enable</code> is pulled high every once every 250 milliseconds, and stays high for one clock cycle. Thus, the counter is incremented at 4 Hz.</p> <p>Example: At t=0 ms, <code>enable</code> is high. Then, at the next clock edge, <code>enable</code> should be low, and it should remain low until t=250 ms. At t=250 ms, enable should be pulled high. Repeat.  </p> </li> <li> <p>If <code>btnC</code> is pressed, <code>enable</code> is never pulled high. </p> </li> <li> <p>If neither <code>btnU</code> nor <code>btnC</code> are pressed, <code>enable</code> is pulled high once every 1000 ms (1 second), and stays high for one clock cycle. Thus, the counter is incremented at 1 Hz.</p> <p>Example: At t=0 ms, <code>enable</code> is high. Then, at the next clock edge, <code>enable</code> should be low, and it should remain low until t=1000 ms. At t=1000 ms, enable should be pulled high. Repeat.</p> </li> <li> <p>Both buttons being pressed simultaneously is undefined behaviour. You may choose the outcome in this case.</p> </li> <li> <p>The system behaviour when both <code>btnU</code> and <code>btnC</code> are pressed together is unspecified. It is left to your choice.</p> </li> </ol> <p>Tip</p> <p>The counter does not need to be exactly 1 Hz or 4 Hz. We will allow some (generous) margin of error.  <p>Using clock enable thresholds that are powers of two could make the hardware simpler, if done properly (How?). However, when <code>btnU</code> is pressed, the counter should be exactly 4 times faster than when it isn't pressed. </p> <p>The 9-bit counter is a sequential block. It uses the system clock <code>clk</code> and the clock enable signal <code>enable</code> to count up a 9-bit number <code>addr</code>. That is, for every positive edge of <code>clk</code>, if <code>enable</code> is high, the counter should increment by 1. <code>addr</code> is the only output of this module.</p> <p><code>addr[7:1]</code> should be used to address both <code>IROM</code> and <code>DMEM</code>. The ROMs will both output whatever value is present in the address <code>addr[7:1]</code>. Then, depending on <code>addr[8]</code>, a multiplexer should choose whether to display the instruction memory or the data memory. The output of this multiplexer is <code>data</code>.</p> <p><code>data</code> is connected as an input to <code>Seven_Seg</code> directly, and the seven-segment displays will display the value from <code>data</code> as a hexadecimal value on the seven-segment display on the board. <code>Seven_Seg_Nexys</code> is already created and does not need to be modified or understood at an implementation level.</p> <p><code>data</code> is also then split into two 16-bit numbers, <code>data[31:16]</code> and <code>data[15:0]</code>. We use <code>addr[0]</code> as a select input to another multiplexer, to choose whether to display the upper or the lower 16 bits on the LEDs.</p> <p>The sequence of events expected, if no buttons are pressed, is:</p> <ol> <li> <p>For one second, the seven-segment displays display the content of <code>IROM[0]</code>, while the LEDs show <code>IROM[0][31:16]</code>.</p> </li> <li> <p>For one second, the seven segment displays display the content of <code>IROM[0]</code>, while the LEDs show <code>IROM[0][15:0]</code>.</p> </li> <li> <p>For one second, the seven segment displays display the content of <code>IROM[1]</code>, while the LEDs show <code>IROM[1][31:16]</code>.</p> </li> <li> <p>For one second, the seven segment displays display the content of <code>IROM[1]</code>, while the LEDs show <code>IROM[1][15:0]</code>.</p> </li> <li> <p>Repeat until the last instruction in <code>IROM</code> is displayed.</p> </li> <li> <p>For one second, the seven-segment displays display the content of <code>DMEM[0]</code>, while the LEDs show <code>DMEM[0][31:16]</code>.</p> </li> <li> <p>For one second, the seven segment displays display the content of <code>DMEM[0]</code>, while the LEDs show <code>DMEM[0][15:0]</code>.</p> </li> <li> <p>For one second, the seven segment displays display the content of <code>DMEM[1]</code>, while the LEDs show <code>DMEM[1][31:16]</code>.</p> </li> <li> <p>For one second, the seven segment displays display the content of <code>DMEM[1]</code>, while the LEDs show <code>DMEM[1][15:0]</code>.</p> </li> <li> <p>Repeat until the last datum (singular form of \"data\"!) in <code>DMEM</code> is displayed.</p> </li> <li> <p>Start again from step 1.</p> </li> </ol> <p>If <code>btnU</code> is pressed, the sequence should be the same, but the interval should be shortened to 250 milliseconds instead of 1 second. The display should not be interrupted or reset, only sped up.</p> <p>If <code>btnC</code> is pressed, the sequence should be paused as long as it is held down, and resume from the same place as soon as it is released.</p> <p>There is no need to add more logic to skip through the empty parts of <code>IROM</code> and <code>DMEM</code>. The design can cycle through the whole memory. </p> <p>We do not care about what happens when the empty/uninitialized parts of <code>IROM</code> and <code>DMEM</code> are accessed, neither in simulation nor in hardware. It can be all <code>X</code> or all <code>0</code>, or anything random. The synthesis tool will probably initialize the empty parts to <code>0</code> or repeat the valid data to fill the uninitialized parts anyway. In a real computer system, access to these unused parts of memory would be considered illegal anyway, and should never happen in a properly written program. </p>"},{"location":"asst_manuals/Asst_01/Asst_01/#design-guide","title":"Design guide","text":"<p>Download the template for Assignment 1 from the labs file repository. Choose the files appropriate for your setup - that is, in your language of preference (Verilog or VHDL), and the constraints file corresponding to the FPGA board model you have. Create a new project and import these files, setting the Top module correctly.  Note that using these templates is not mandatory; you may wish to implement completely on your own. </p> <p>Tip</p> <p>Vivado (like many other IDEs) does not take too kindly to project paths that are too long, contain special/non-English characters, or are in some cloud synchronised folder like OneDrive, Google Drive or Dropbox. All sorts of weird bugs may crop up, which are hard to debug. </p> <p>Vivado projects should ideally be stored in a folder with a short and sweet name, that is not continuously synchronised to the cloud. For backups, collaboration and version control, <code>git</code> should be used - whether GitHub, Gitlab or any other implementation.</p> <p>In total, we will need <code>Top_Nexys</code>, <code>Seven_Seg_Nexys</code>, <code>Clock_Enable</code>, <code>Get_MEM</code>, and one <code>.xdc</code> file corresponding to our board.</p> <p>Warning</p> <p>The Nexys 4 and Nexys 4 DDR/Nexys A7 use the same FPGA chip on board, but the pins are connected differently. Thus, the part number we choose when creating a new project is the same for both (XC7A100T-1CSG324C), however, the constraints file is different. Using the wrong constraints file will work for simulation, synthesis, implementation and even bitstream generation - but the bitstream will not work on the board!</p> <p>We need to fill out <code>Clock_Enable</code>, <code>Get_MEM</code> and <code>Top_Nexys</code> to achieve the functionality described above. </p> <p>The hexadecimal text dump should be saved with a <code>.mem</code> file extension. These files can be imported into our Vivado project as design sources, and used to initialise memories using the <code>$readmemh()</code> command. </p> <p>Do NOT use a clock divider, like you may have used in EE2026. They can cause all sorts of issues, since it becomes difficult for the synthesis tool to route the clocks. </p>"},{"location":"asst_manuals/Asst_01/Asst_01/#how-to-design-a-clock-enable","title":"How to design a clock enable","text":"<p>Here is some example code that may help better illustrate how a clock enable should be implemented. This is just an example, not necessarily something you will be able to just copy/paste and use; but it should give you an idea of how it should be implemented. </p> VerilogVHDL <pre><code>always @(posedge clk) begin\n    count_fast &lt;= count_fast+1;\n    if(count_fast == 26'h3FFFFFF) begin // EITHER change this to a lower value (say 26'h0000004) for simulation (recommended)\n        count_slow_enable &lt;= 1'b1;\n    end\n    else begin\n        count_slow_enable &lt;= 1'b0; // OR change this to 1'b1 for simulation\n    end\nend\n\nalways @(posedge clk) begin\n    if(count_slow_enable) begin\n        count &lt;= count+1;\n    end\nend \n</code></pre> <pre><code>process(clk)\n    variable count_fast :std_logic_vector(25 downto 0):=(others=&gt;'0');\nbegin\n    if clk'event and clk='1' then\n        count_fast := count_fast+1;\n        if count_fast = x\"3FFFFFF\" then -- EITHER change this to a lower value (say x\"0000004\") for simulation\n            count_slow_enable &lt;= '1';\n        else\n            count_slow_enable &lt;= '0'; -- OR change this to '1' for simulation;\n        end if;\n    end if;\nend process;\n\nprocess(clk)\nbegin\n    if clk'event and clk='1' then \n        if count_slow_enable = '1' then\n            count &lt;= count+1;\n        end if;\n    end if;\nend process; \n</code></pre>"},{"location":"asst_manuals/Asst_01/Asst_01/#simulation","title":"Simulation","text":"<p>Simulation is required for this assignment, but nothing too complicated - a simple simulation of the <code>Top_Nexys</code> module will suffice. The simulation should cover all possible input cases. Needless to say, the simulation should be show the correct result!</p> <p> For more info on simulation controls, see the CS2100DE section on simulation. These are extremely handy once you figure out how to use them. Similar in spirit to using a software debugger, but with notable differences given HDLs have very different semantics.</p> <p> For simulation, checking the raw 32-bit <code>data[31:0]</code> to the Seven_Seg module will suffice, as making sense of anodes and cathodes, especially given the time-division multiplexing used, is hard. It can be checked by dragging it into the waveform window; there is no need to make it as a port of the top level module just for simulation purposes. To see data, go to scope window &gt; testbench_name &gt; uut, and then drag <code>data</code> signal from object window to the waveform window (scope and object windows are to the immediate left of the waveform window). Need to rerun (no need to relaunch) the simulation to see the <code>data</code> waveform. Save the waveform configuration file (Ctrl+S) and add it to the project (it will ask whether you wish to add to project when you save), and it'll be available when you stimulate in the future. </p> <p>Feel free to make your simulation more rigorous by automatically checking test cases, and using $error() to halt the simulation if any don't pass. This is not required, but will make for an impressive demo. </p> <p>Warning</p> <p>Do not move on to the next step without writing a good simulation, and making sure the design can pass it! If the simulation doesn't work, there is no chance the hardware will. However, if the simulation does work, the hardware is almost guaranteed to work too. The most common reason for designs that work in simulation not to work on hardware is mistakes in the constraints file, or faulty hardware. </p> <p>Do either of the two modifications mentioned as comments in the code in the previous section.\u00a0Else, you will have to wait for\u00a0about 2^26 cycles\u00a0(for a ~1Hz clock) before you can see the effect of 1 clock edge in simulation! This will take a long long time, and is really unnecessary in the simulation. Do not forget to revert these changes before synthesis and implementation. </p> <p> We can get a very very good sense of whether it will work on hardware by doing a post-synthesis functional simulation by Simulate &gt; Post-synthesis functional simulation. Obviously, synthesis should be done before this, but further steps such as implementation need not be done. The same testbench can be used, so it requires zero extra effort. However, debugging is much harder than it is with behavioral simulation as some of the internal signals are optimized away and/or renamed (still easier than try to debug directly on hardware). As with standard simulation, use a low value for clock enable threshold, so that you don't have to run sim for very long to see results. For actual hardware implementation, change the threshold to the original high value, run synthesis and implementation. </p> <p> Simulation (especially when done at the top/system level) is meant to simulate a real life user interacting with the system. Say, you plan to press <code>btnU</code> 3 seconds after powering on, and release it 2 seconds after pressing. In your testbench initial block, delay by 3 x threshold_count x 10 ns (#480 if the threshold is 16), assert <code>btnU</code>, wait for 320 ns (#320), deassert <code>btnU</code>. </p>"},{"location":"asst_manuals/Asst_01/Asst_01/#constraints","title":"Constraints","text":"<p>Before run synthesis and implementation, remember to set up the constraints file correctly. Uncomment the lines corresponding to the pins used - no more, no less. Make sure the names in the constraints file match the inputs and outputs of the <code>Top_Nexys</code> module. Then, run Synthesis, Implementation and Generate Bitstream to generate the bitstream to upload to your board. </p>"},{"location":"asst_manuals/Asst_01/Asst_01/#tips","title":"Tips","text":"<ul> <li>Chapter 2 from the lecture notes contains important design guidelines - these should be followed religiously. In particular, Chapter 2B explains how to write synthesisable HDL code, which is very useful for making designs that work optimally and as intended.</li> <li>Clock enables should be used if the clock needs only be active in certain situations, i.e., to get the effect of a slow clock, e.g., to change data on LEDs. Clock dividers should be avoided.</li> <li>Instead of making the whole design in one go and praying that it synthesises correctly, we can always set individual modules as Top and synthesise one by one. This makes errors and bugs much easier to detect and solve.</li> <li>\"View Elaborated Design\" -&gt; \"Schematic\" is a very powerful tool to visualise the circuit generated. Liberal use of the schematic can help prevent bugs and unexpected design oddities.</li> <li>Similarly, the synthesis report can contain some hints on where things are going wrong. We can check to see if the primitives being inferred make sense for our design.</li> <li>Vivado's text editor is, perhaps, not the greatest ever made. We recommend using a more cromulent alternative, such as Notepad++ or Visual Studio Code.</li> <li>Writing good HDL code is a skill that takes a lot of practice. It is a completely different paradigm to (and should never ever be confused with) software programming. The best teacher is experience, and practice really does help. Following the guidelines from Chapter 2, and being very conscious about the hardware we expect our code to generate, is key.</li> <li>For this design, debouncing the switches is really quite extra and not necessary. (Why?) Feel free to look into a metastable filter, although it is also unnecessary for this design.</li> </ul>"},{"location":"asst_manuals/Asst_01/Asst_01/#submission-and-demonstration-instructions","title":"Submission and demonstration instructions","text":""},{"location":"asst_manuals/Asst_01/Asst_01/#submission","title":"Submission","text":"<p>Once you have finished the assignment, you must submit your work to Canvas. You should submit a single zip file. The file should contain:</p> <ol> <li>The assembly language program (ending with <code>.s</code> or <code>.asm</code>), if you have modified it. If not, skip this one. </li> <li>The HDL sources for your project, i.e. all of the <code>.v</code>/<code>.vhd</code>/<code>.sv</code> files for modules, testbenches, etc.</li> <li>The <code>.xdc</code> constraints file.</li> <li>The <code>.bit</code> bitstream file.</li> <li>A screenshot of the simulation waveform as a <code>.jpg</code> file. All of the signals in the design should be captured - there aren't that many, so they should fit on your screen. If you need to use multiple screenshots to make it clear, feel free to do so. </li> </ol> <p>Your submission must be made to Canvas before the start of your lab session in Week 5. The exact deadline for your submission will be visible on Canvas. </p>"},{"location":"asst_manuals/Asst_01/Asst_01/#demonstration","title":"Demonstration","text":"<p>Before your lab session in Week 5, you will be assigned a time slot of 7 minutes for your demonstration. </p> <p>Arrive at the lab at least 30 minutes before your assigned time slot. If you are one of the earlier time slots, you need not arrive more than 15 minutes before the start of the lab timing (i.e. before 17:45 or 08:45). </p> <p>The time will be split as follows:</p> <ul> <li>2 minutes to demonstrate Task 1, using RARS. You should show that you are able to follow the instructions in Task 1. </li> <li>2 minutes to demonstrate Task 2, on the FPGA board. You should show that the design specified for Task 2 is implemented correctly with all features functional.</li> <li>3 minutes for two questions from the GA assessing you.</li> </ul> <p>The time is extremely tight - with so many of you, we do have to be quick :3. If you are not there when we are ready to assess you, we will skip past you and start assessing others. You will be bumped to the bottom of the queue, and we will not assess you until everyone else is done. (On the flip side, if you are nice and early, and someone misses their turn - good news, you might get to go home early :D)</p> <p>Note that you will not have extra time to open programs, load projects, etc.. Make sure you have opened RARS and Vivado, and have the bitstream ready to upload to your board. Any extra time you take to do these tasks will eat into the time for the demonstration. We will not exceed your allotted time for demonstration.</p>"},{"location":"asst_manuals/Asst_01/Asst_01/#penalties-for-late-submission","title":"Penalties for late submission","text":"<p>Late submissions and demonstrations up to one week will be allowed, with a penalty of 50%. Beyond one week, submissions will not be accepted. </p> <p>This policy is non-negotiable, aside from the usual NUS clauses such as being unwell (Medical Certificate strictly required), authorised competitions, family emergencies etc. </p>"},{"location":"asst_manuals/Asst_01/Asst_01/#conclusion","title":"Conclusion","text":"<p>Congratulations! With the first assignment finished, we are now comfortable with FPGA design and assembly programming. We are ready to dive into the proper content of the course. In the next assignment, we will have our CPU up and running - it's going to be exciting.</p> <p>What we should know</p> <ul> <li>How to write and simulate RISC-V assembly programs.</li> <li>How to use MMIO in our RISC-V assembly programs to control peripherals.</li> <li>How to use Vivado to create a design for the FPGA board.</li> <li>How to translate a block diagram into an implemented design for FPGA.</li> </ul>"},{"location":"asst_manuals/Asst_02/Asst_02/","title":"Assignment 2: Implementation of a RISC-V 32-bit (RV32I) Processor","text":"<p>Info</p> <p>Assignment 2 consists of 1 task, with 2 subtasks, for a total of 30 points. </p> <p>Assignment 2 is a group exercise. You will be assessed as a group, but scored individually. </p>"},{"location":"asst_manuals/Asst_02/Asst_02/#objective","title":"Objective","text":"<p>In this assignment, we will be implementing the basic RISC-V (or ARM!) processor supporting only limited 32-bit integer instructions.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#requirements","title":"Requirements","text":"RISC-VARM <p>Implement the following instructions:</p> <ul> <li><code>add</code>, <code>addi</code>, <code>sub</code>, <code>and</code>, <code>andi</code>, <code>or</code>, <code>ori</code></li> <li><code>lw</code>, <code>sw</code></li> <li><code>beq</code>, <code>bne</code>, <code>jal</code> (without linking, that is, without saving the return address).\u00a0</li> <li><code>lui</code>,<code>auipc</code></li> <li><code>sll</code>, <code>srl</code>, <code>sra</code></li> </ul> <p>Implement the following instructions:</p> <ul> <li><code>LDR</code>, <code>STR</code> (Both with positive immediate offsets)</li> <li><code>AND</code>, <code>OR</code>, <code>ADD</code>, <code>SUB</code> (Where <code>Src2</code> is register or immediate without shifts)</li> <li><code>B</code></li> <li><code>CMP</code></li> <li><code>LDR</code>, <code>STR</code></li> <li>Immediate shift support for <code>Src2</code> in DP instructions (i.e. <code>LSL</code>, <code>LSR</code>, <code>ASR</code>, <code>ROR</code>) (3 points)</li> </ul> <p>No extra points will be awarded for performance enhancements / adding support for more instructions (that's for Labs 3 and 4). However, a lack of convincing demos (with carefully crafted assembly language programs) can result in the deduction of points.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#design-files","title":"Design Files","text":"<p>The design files can be found on the GitHub repository. Download them and import them into a new Vivado project, using the same settings as Assignment 1.</p> <p>Warning</p> <p>The FPGA part number we need is <code>xc7a100tcsg324-1</code>. Using the wrong, or any random, part number, will not work. Actually, even worse - it will work until we try to generate the bitstream, and then error out. ~Fun!</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#file-hierarchy","title":"File hierarchy","text":"<p>Described below is the file/module hierarchy for the project we will use. Note that we do NOT simulate the <code>TOP_Nexys</code> module. Instead, the system is designed such that we can simulate the <code>Wrapper</code> module, using <code>test_Wrapper.v</code> as a testbench. We can assume <code>TOP_Nexys</code> works correctly without simulation, as long as the <code>Wrapper</code> is correctly implemented.</p> <p>This means we have two similar, but slightly different, module hierarchies for simulation and for hardware.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#for-simulation-and-testing","title":"For simulation and testing","text":"<pre><code>test_Wrapper.v                  // Top level module for simulation\n    |\n    - Wrapper.v                 // Unit under test for simulation\n        |\n        - RV.v                  // Our CPU!\n            |\n            - ALU.v\n                |\n                - Shifter.v\n            - Decoder.v\n            - Extend.v\n            - PC_Logic.v\n            - ProgramCounter.v\n            - RegFile.v\n</code></pre>"},{"location":"asst_manuals/Asst_02/Asst_02/#for-hardware-implementation","title":"For hardware implementation","text":"<pre><code>- TOP_Nexys.vhd             // Top level module for hardware implementation\n    |\n    - ADXL362Ctrl.vhd\n        |\n        - SPI-If.vhd\n    - pmodoledrgb_bitmap.vhd\n    - uart.vhd\n    - Wrapper.v               // Unit under test for simulation\n        |\n        - RV.v                  // Our CPU!\n            |\n            - ALU.v\n                |\n                - Shifter.v\n            - Decoder.v\n            - Extend.v\n            - PC_Logic.v\n            - ProgramCounter.v\n            - RegFile.v\n</code></pre>"},{"location":"asst_manuals/Asst_02/Asst_02/#setting-up-the-project","title":"Setting up the project","text":"<p>Import all the relevant files into your project - all the .v files, as well as <code>TOP_Nexys.vhd</code> and <code>uart.vhd</code>, <code>ADXL362Ctrl.vhd</code>, <code>SPI_If.vhd</code>, <code>pmodoledrgb_bitmap.vhd</code> - irrespective of whether you use these peripherals.</p> <p>Warning</p> <p>It is very important to ensure that the top-level module is set correctly in our project: <code>TOP_Nexys</code> for implementation, and <code>test_Wrapper</code> for simulation.\u00a0The Top module can be set independently for implementation and simulation. Simply right-click the appropriate file under Design Sources or Simulation Sources, and click \"Set as Top\". The module selected as the top should appear in bold with a small, grey-and-green icon by its side.</p> <p>If we just select <code>TOP_Nexys</code> as the top module for implementation, Vivado may automatically select it as the top module for simulation as well. We do not want this, so remember to set <code>test_Wrapper</code> as the top module for simulation. </p> <p>Choose the appropriate constraint file for your board.<sup>1</sup> The files are pretty self-explanatory. It is possible to mix VHDL and Verilog files in the same project. Note that TOP/uart.vhd is the same as that for the ARM version. All other files have differences, though in many cases, the differences are minor.</p> <p>Tip</p> <p>We have found that AI tools (ChatGPT in particular) is pretty decent at converting our Verilog template files into VHDL. If you are a VHDL fan (as some of the teaching team are), feel free to try this.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#why-does-the-wrapper-exist","title":"Why does the Wrapper exist?","text":"<p><code>Wrapper</code> is a convenient testbed to plug our processor (RV) into and simulate it using <code>test_Wrapper</code> as the testbench - see below for more details on how to modify the <code>test_Wrapper</code> appropriately. <code>Wrapper</code> provides instruction/data memory and a set of abstract peripherals with easy-to-view (parallel) signals. The abstract peripherals of the Wrapper are converted to real protocol/interfacing signals  (often serial/not easy to make sense of) by <code>TOP_Nexys.vhd</code>. For example, <code>UART_RX</code>/<code>UART_TX</code> (parallel) of the Wrapper to <code>RX</code>/<code>TX</code> (serial, external signals) of UART, anode and cathode activation signals of the 7-segment display. Writing a testbench to simulate RV directly is unnecessary. The Wrapper is not very modular, but was kept that way to make it self-contained and hence avoid having too many files.</p> <p><code>Wrapper.v</code> for ARM and RISC-V are almost identical. The only notable difference is in the memory map, and also the fact that the wrapper for ARM has not been updated since 2024.</p> <p>When simulating, the <code>test_Wrapper</code> -&gt; <code>Wrapper</code> -&gt; <code>RV</code> relationship is analogous to that of a User -&gt; System/Motherboard -&gt; Processor.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#what-code-to-modify","title":"What code to modify","text":"<p>There are basically 4 files we need to\u00a0populate / modify\u00a0\u00a0-\u00a0PC_Logic.v\u00a0,\u00a0Decoder.v\u00a0,\u00a0RV.v\u00a0; we will also need to add our code / constant memories hex values\u00a0into\u00a0Wrapper.v.\u00a0A 5th file, ALU.v should also be modified to incorporate shifts.</p> <p>There are 5 files we must populate/modify:</p> <ol> <li><code>ALU.v</code>: we must modify the ALU to incorporate shifts.</li> <li><code>Decoder.v</code></li> <li><code>PC_Logic.v</code></li> <li><code>RV.v</code></li> <li><code>Wrapper.v</code>: we need to add our Instruction and Data ROMs here. This can be done in the same way as Assignment 1.</li> <li><code>TOP_Nexys.vhd</code>: we may need to modify <code>CLK_DIV_BITS</code> depending on the processor clock speed we want to achieve (we can keep it to a low\u00a0number like 5 if we are using UART). This need not be changed for simulation as <code>TOP_Nexys.vhd</code> is not simulated. Changing CLK_DIV_BITS to 0 causes the frequency to be 100 MHz, but unless you do lots of optimizations such as pipelining.</li> </ol> <p>You are expected to know the functionality of all components of the RISC-V processor (RV module and its sub-modules*), irrespective of who wrote it - you or your teammate or provided as a part of the templates or assisted by AI (in which case you should declare the prompts used as a comment, and also verbally to the evaluator). You need not understand <code>TOP</code>. A fair understanding of <code>Wrapper</code> is essential; a deeper understanding is recommended though not mandatory.</p> <p>*For assignment #2, a deeper understanding of the shifter component is not essential. For future assignments, it is.</p> <p>Tip</p> <p>Read the comments (especially about the input and output ports / interfaces) in the <code>Wrapper.v</code> carefully.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#guidelines","title":"Guidelines","text":"<p>The following section is an extensive set of design guidelines that you must follow for this (and subsequent) assignments. There are a lot, so we have broken them down into subsections to make it easier to read and understand them all. Which is really, really, really important.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#designing-the-alu","title":"Designing the ALU","text":"<p>All arithmetic, logical, and shift operations on 32-bit numbers should be done in the ALU, except for the new PC (PC+ aka PC_IN) computation.</p> <p>We should use <code>+</code> on 32-bit numbers only in 2 statements: one to compute the new PC value, and one statement in ALU. In other words, only 2 32-bit adders can be used in the whole system. A single-cycle processor cannot be implemented with less than 2 adders, but a multi-cycle design can be - this will require the ALU to be used for PC increment in a second cycle for the same instructions.</p> <p>You are not required to implement your own carry look ahead or ripple carry adders. The <code>+</code> operator synthesizes a circuit that makes use of the built-in carry acceleration logic built into most FPGAs.<sup>2</sup> However, if you insist on implementing your own adder logic for the sake of learning, please go ahead. It will use the general-purpose fabric/routing, which will almost certainly be slower (doesn't matter for lower frequencies though).</p> <p><code>=</code> should not be used on 32-bit numbers for Lab 2. The comparison for conditional branch should be done inside the ALU through subtraction. <code>=</code> may be used in other places such as the control unit, to implement multiplexers in the datapath, for checking the value of counter(s) for Lab 3 MCycle unit, etc., but this comparison is done on values that are much less than 32 bits.<sup>3</sup></p> <p>All Shift operations on 32-bit numbers should be done in the Shifter unit.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#general-hardware-design","title":"General hardware design","text":"<p>DO NOT create additional entities/modules. Components such as multiplexers are easily implemented using when-else / with-select / if / case statements. Leave PC_Logic and Decoder separate (do not combine them into one ControlUnit entity). However, the interfaces for entities could be modified slightly to meet the design requirements.</p> <p>DO NOT modify the ports of the entity RISC-V, unless you want to take responsibility for the wrapper module.</p> <p>It is a good idea to use <code>-</code> (VHDL) or <code>X</code> (Verilog) for don't cares, as it could simplify the combinational logic. However, there are 2 points to note:</p> <ol> <li>Using don't cares with signals which change the processor state (RegWrite, PCSrc, MemWrite) would make the system vulnerable to illegal instructions.</li> <li>Don't cares can cause different behavior in simulation and synthesis. Don't cares are treated as don't cares in simulation, whereas in synthesis, it could be a random 0 or 1 (whichever simplifies logic better).</li> </ol> <p>Reset resets only the program counter. The register initial values are not guaranteed to be zero. This requires you to write to a register before using/reading it.</p> <p>You can add more peripherals (RGB LED, accelerometer, VGA display, etc.) to the Wrapper if you wish. The corresponding changes will also need to be done in the top-level .vhd and .xdc files.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#simulation","title":"Simulation","text":"<p>We must simulate our design and verify its functionality. All debugging should be done in simulation, not in hardware. Furthermore, while developing and testing our design, we should also try synthesizing to ensure that our design is synthesizable without avoidable warnings and errors.</p> <p>It will be incredibly useful to learn how to use debugging options such as single stepping, breakpoints, running for a specified time, etc. These can help tremendously. However, note that some options such as single stepping work a bit differently from conventional software debugging, due to the inherent parallel nature of HDLs, as well as the fact that non-blocking assignments do not have an instantaneous effect on the LHS. Some additional info is given in the Tips section, and there is a demo on this during the assignment briefing.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#assembly-programming","title":"Assembly Programming","text":"<p>Use your own, well-crafted assembly language programs for a convincing demo (to demonstrate that all the required instructions and variants work). One single program demonstrating all the features is desirable. Conversely, make sure that your program only uses the features that you have already implemented; notably, we cannot use any multiplication operations, nor many shift operations or <code>xor</code>. If you were unable to implement some of the required instructions, make sure your assembly program doesn't use those; otherwise, the demo will be quite disappointing.</p> <p>By 'convincing demo', what we mean is having an assembly language program that tests all the features of all instructions of a particular type. For example, if you demonstrate <code>addi</code>, you don't really have to show <code>andi</code>, <code>ori</code>,\u00a0as it can be expected to work, as the datapath activated is the same, and the control signals are derived in a manner that is unlikely to be wrong for one if it is correct for the other (this isn't the case, for example, for <code>srl</code> and <code>sra</code>). Instructions such as conditional branches should be used, such that both possibilities - i.e., branch taken and branch not taken should be demonstrated. In other words, it should provide an exhaustive 'coverage' of your HDL code. Your program should be crafted such that if one instruction misbehaves, the overall behavior of the program should be different - this is the case for most programs, as long as you use the result from every instruction in a subsequent instruction - i.e., there is no 'dead code' or have pairs/groups of instructions that cancel each others' effect (e.g., addition and subtraction by the same amount - which could have correct results even if both instructions misbehave).</p> <p>Please follow the instructions in\u00a0the\u00a0RISC-V Programming\u00a0page to configure RARS and to write programs. The .hex file generated by the program is inserted into the ROMs within Wrapper.v directly to \"program\" the RISC-V processor. Note: Instruction and data memory sizes can be bigger than 128 words. Be mindful of the potentially increased synthesis time though. Addresses except <code>IROM_BASE</code> and <code>DMEM_BASE</code> are hierarchically derived instead of hard-coding.</p> <p>Simulate your assembly language program thoroughly - else when something goes wrong, you won't know if the problem is with your HDL code (hardware) or the assembly language program (software).</p> <p>The Assignment 1 program may be a good place to start while you work on the hardware; modify it to only use the instructions you have implemented, and maybe add more instructions as you implement them.</p> <p>Byte (<code>sb</code>) and half-word (<code>sh</code>) writes are supported for data memory and peripherals like the 7-segment display. Ensure memory addresses are aligned, and data is pre-shifted/aligned accordingly.</p> <p>Tip</p> <p>Byte and half-word read don't require any Wrapper support - you can simply read the whole byte, extract the byte/half-word, and extend as necessary.</p> <p>The provided assembly language programs are neither meant to be comprehensive programs that test everything. Do not use the programs under Optional_Stuff as your first program.\u00a0Use the DIP_to_LED.asm instead. Even this will need appropriate modifications to include instructions such as DP reg type, bne, and shifts in a meaningful manner.</p> <p>The <code>test_Wrapper.v</code> you use is specific to the assembly language program being run. It simulates the scenario of giving inputs externally manually/from sensors, and getting the output on various displays/UART. Depending on the inputs your .asm program expects, the stimuli of your testbench will have to change too.</p> <p>You could use the program that you simulated in RARS in Lab 1 as a starting point if you have implemented <code>lui</code> and <code>auipc</code>. However, you will need to make appropriate modifications to include instructions such as R type, <code>bne</code>, and shifts in a meaningful manner. The <code>test_Wrapper</code> should be modified to give appropriate stimuli, as mentioned in the previous point. You can use it even before incorporating <code>lui</code> and <code>auipc</code>, but you will need to change it such that s1 and s2 are loaded from memory.</p> <p>There is no requirement that you should use all the peripherals supported by the Wrapper. As long as your demo is convincing, it is fine to use only a limited set of peripherals (say, LEDs and DIP switches - at least one input and one output). RISC-V Memory Map\u00a0page has more details about the address and usage of the supported peripherals.</p> <p>To use a C compiler to generate code, please follow the instructions at Using Compiled Code. However, note that this works only if the compiler does not generate any instruction that your processor doesn't support at this point.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#tips","title":"Tips","text":"<p>The following section details some tips and tricks that will make your life a lot easier. We recommend at least reading them and being aware these are all possible, even if you do not actually use all of this information.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#hardware-design-tips","title":"Hardware design tips","text":"<ul> <li> <p>Re-run synthesis if you have changed the .mem file contents, even when the tool tells you that synthesis is up to date.</p> </li> <li> <p>Synthesize modules that you edit, such as decoder and conditional logic by setting them as top-level modules even before simulation. The synthesis tool is much smarter than the simulation tool - synthesis reports and warnings can give you a wealth of information.</p> </li> <li> <p>Looking at RTL Analysis &gt; Open Elaborated design gives you insights into the schematic (block design) inferred from your code. This can be very useful in debugging. Pay particular attention to the bit widths for each connection etc. You can get even more information from the synthesis report.</p> </li> <li> <p>If you try to run the design from a 100 MHz clock directly (<code>CLK_DIV_BITS = 0</code>, i.e., without dividing the clock), you will most certainly get a critical warning that the timing constraints are not met (Why?).\u00a0 Your design may or may not work on hardware, and it is unreliable even if it works. A pipelined design (Lab 4) should work directly from 100 MHz.</p> </li> <li> <p>The default processor clock frequency is 5 MHz which is ideal for UART, but too fast for LEDs - you will see the LEDs constantly lit, but different LEDs may have different brightness (why?). To see the output on LEDs, you need to have the LEDs changing state slow enough. There are two ways to do it:</p> <ol> <li>by using a slow clock for the processor. This is done by setting the <code>CLK_DIV_BITS</code> to a value of around 26.</li> <li>by having a fast clock <code>CLK_DIV_BITS\u00a0= 1</code> for 50MHz), but using software delays (using a high value for <code>DELAY_VAL</code> between LED writes).</li> </ol> <p>However, note that you should use a very low <code>DELAY_VAL</code> during simulation. Else, you might have to run simulation for a long time to get past the delay. Make sure you change either of them to a high value before implementation/bitstream generation. Similar considerations apply while sending data via UART.</p> </li> <li> <p>By default, Vivado will run significantly slower in Windows than in Linux, due to the differences in the number of threads used. A workaround is mentioned in the AMD documentation</p> </li> <li> <p>To implement <code>lui</code> and <code>auipc</code>, you will need to have a multiplexer at <code>SrcA</code>. The <code>ALUSrcA</code> control signal needs to be implemented properly too.</p> </li> <li> <p>The signals connected to the ports are given the same name as the ports themselves. So making the datapath connection is as easy as having a concurrent statement (VHDL) such as\u00a0<code>Opcode\u00a0&lt;= Instr(6 downto 0)</code> / continuous assignment\u00a0(Verilog) such as <code>assign Opcode\u00a0= Instr[6:0]</code>.</p> </li> </ul>"},{"location":"asst_manuals/Asst_02/Asst_02/#simulation-tips-and-tricks","title":"Simulation tips and tricks","text":"<ul> <li> <p>Please SIMULATE your design before spending your time on bitstream generation. Make sure your design synthesizes without warnings (if at all there are warnings, you should know the reasons, and you should ensure that the warnings do not affect the functionality). If you don't simulate and click 'generate bitstream' hoping it would work on the board, you are probably wasting your time. This can't be emphasized enough.</p> </li> <li> <p>You can get a very very good sense of whether your design will work on hardware by doing a\u00a0post-synthesis functional simulation by Simulation &gt; Run Simulation &gt; Post-synthesis functional simulation (Instead of the usual Behavioural Simulation).</p> </li> <li>The same testbench can be used, so it requires zero extra effort.</li> <li>Debugging is much harder than it is with behavioral simulation as some internal signals are optimized away and/or renamed (still easier than it is with hardware).</li> <li> <p>For post-synthesis functional simulation, either the Wrapper or the TOP should be set as the top-level module for synthesis, and then the module should be synthesized before it can be (post-synthesis) simulated. Note, however, though that setting the Wrapper as top for synthesis will cause a lot of warnings as there are mismatches in location constriants with the .xdc file; the top level module for synthesis will have to be changed back to TOP anyway for implementation.</p> </li> <li> <p>Make sure that the HDL testbench, .asm, .mem always correspond.</p> </li> <li> <p>Relaunch simulation after changing .mem.</p> </li> <li> <p>A self-checking testbench can be quite useful. You may use LLM tools for that. Tools such as Claude tends to do a better job than ChatGPT for this (in our experience). Declare LLM tool+version, and prompts used as a comment. For example, the test_Wrapper_DIP_to_LED.v is convereted to sel-checking test_Wrapper_DIP_to_LED_self_checking.v via a prompt that is declared as a comment in the latter file.</p> </li> <li> <p>You can go into the subunits and see their value for each instruction (Scope-Objects) - this is much easier than what most of you think. This is more powerful than dragging the various signals into the waveform. Note that the values you see are those at the time the simulation has stopped/paused, not the time corresponding to the yellow vertical bar in the waveforms window. Double-clicking the Scope-Objects will lead you to the source code - you can then hover the mouse pointer above various objects to see their values.</p> </li> <li> <p>Make sure your radix in the waveform window / Scope-Objects is set correctly. Looking at hexadecimal and assuming them to be decimal or vice versa is a common mistake. Saving the waveform window (<code>.wcfg</code>) and adding it to the project will ensure that such settings get saved. For UART input/output, setting the radix to ASCII can be useful.</p> </li> <li> <p>Have the RARS simulator side by side so that you can compare the register/memory values between that in RARS and HDL register/memory objects. While you single step in RARS, you can also run by 10 more ns to have the same effect in HDL simulation. It helps to have the PC and Instr values in the waveform window to see the correspondence between RARS and HDL simulations, i.e., to ensure that you are looking at the same instruction on the two tools.</p> </li> <li> <p>Don't forget to Relaunch simulation (not just Restart) once you have made any changes to your HDL.</p> </li> </ul>"},{"location":"asst_manuals/Asst_02/Asst_02/#expected-warnings","title":"Expected warnings","text":"<ul> <li> <p>Warning about <code>indices_reg</code>: This is related to the seven-segment display and can be ignored.</p> </li> <li> <p>Warnings about <code>Funct7</code> bits other than <code>Funct7[5]</code> being unused: This is also expected.</p> </li> <li> <p>Warnings about <code>Shifter</code> connections and <code>ALUFlags</code>: may appear until you connect them. After connecting them, they should go away.</p> </li> <li> <p>Warnings (~100 in number) about unconnected stuff being removed: chances are that you haven't initialized the ROMs.</p> </li> <li> <p>If you are synthesizing after setting a module other than TOP as the top-level module, you will get warnings such as those below. If your intention is to check the synthesizability of modules one by one, these warnings can be safely ignored (Why?).</p> </li> <li><code>'set_property' expects at least one object.</code></li> <li><code>create_clock:No valid object(s) found for '-objects [get_ports CLK_undiv]'</code></li> </ul>"},{"location":"asst_manuals/Asst_02/Asst_02/#submission-info","title":"Submission Info","text":"<ul> <li>You will have to demonstrate your design during your designated lab session\u00a0in\u00a0Week 7. The presentation schedule can be found on Canvas.</li> <li>One single program demonstrating all the features is desirable.</li> <li>Please upload a\u00a0single archive containing all the relevant files to Canvas\u00a0within 1 hour of your demo.</li> <li>Include:</li> <li><code>.vhd</code>/<code>.v</code> files you have created/modified (RTL Sources, Testbench(es))</li> <li><code>.bit</code>\u00a0files</li> <li><code>.asm</code>\u00a0and <code>.c</code> (if applicable) files</li> <li>a\u00a0<code>readme.txt</code>, mentioning the purpose of each file (only those you have created/modified) briefly</li> </ul> <p>in an archive with the filename <code>Assignment2_&lt;lab day&gt;&lt;group number&gt;.zip</code>, e.g. Assignment2_Monday01.zip. One submission per group is sufficient \u2013 if there are multiple submissions, the file with the latest timestamp will be taken as the final submission.</p> <p>Warning</p> <p>Do not\u00a0zip and upload the complete project folder \u2013\u00a0only those files mentioned above should be included.\u00a0The files should be the exact same files that you used for the demo.</p>"},{"location":"asst_manuals/Asst_02/Asst_02/#conclusion","title":"Conclusion","text":"<p>Congratulations on completing Assignment 2! You now have a somewhat-working RISC-V CPU that can run some real programs. This is no small achievement, and now is a good time to pat yourself on the back for what you've achieved so far.</p> <p>The next two assignments will build upon, extend, and improve this CPU, to a very impressive design by the end. We hope you're as excited for this as us!</p> <p>What we have learned</p> <ul> <li>The basic microarchitecture for a simple, single-cycle RISC-V CPU.</li> <li>How to use Vivado and HDL to implement a fairly complex design on an FPGA.</li> <li>The importance of proper simulation to verify functionality, as well as the steps to create this.</li> <li>How to write assembly language programs, and how they are executed by a CPU.</li> </ul> <ol> <li> <p>It is a good idea to delay importing the constraints file and the TOP_.vhd file until you are ready to test on hardware. Not having the constraints file during the design / simulation phase can help avoid some warnings related to synthesis when you try synthesizing a module that does not have the interfaces specified in the constraints file. Alternatively, import it, but keep it disabled until you need it in Project Manager &gt; Sources &gt; Constraints &gt; right-click and Disable File.\u00a0\u21a9 <li> <p>carry chain, carry lookahead logic - Google for CARRY4\u00a0\u21a9</p> </li> <li> <p>We may need <code>=</code> on 32-bit numbers in Lab 4 if we are implementing branch prediction, but that is optional and far away from where we are now :).\u00a0\u21a9</p> </li>"},{"location":"asst_manuals/Asst_03/Asst_03/","title":"Assignment 3: Multiplication / Division units","text":"<p>Final</p> <p>This page is now final. Updates will be minimal, and will be highlighted. </p> <p>Info</p> <p>Assignment 3 involves 2 compulsory tasks worth 13 and 7 points, and one open-ended task worth 5 points.</p>"},{"location":"asst_manuals/Asst_03/Asst_03/#task-1-implementing-division-13-points","title":"Task 1: Implementing division (13 points)","text":"<p>For Task 1, we will incorporate division (both signed and unsigned) into the MCycle unit given\u00a0[HDL\u00a0simulation only] (13 marks).</p> <ul> <li>The design files can be found here (VHDL) and here\u00a0(Verilog - please do not change the non-blocking assignments in the IDLE_PROCESS to blocking, as it is necessary to circumvent a certain non-deterministic behaviour from Verilog simulator). Please go through the comments carefully to understand its operation.</li> <li>Simulate it using a good testbench, and synthesize the MCycle unit by setting it as the top-level module to make sure it synthesizes without warnings\u00a0(unless you are sure it can be ignored) before doing the next task (incorporating it into the processor).</li> <li>We can assume that the divisor is never zero.</li> </ul>"},{"location":"asst_manuals/Asst_03/Asst_03/#task-2-incorporating-mcycle-into-our-cpu-7-points","title":"Task 2: Incorporating MCycle into our CPU (7 points)","text":"<p>For Task 2, we must incorporate the <code>MCycle</code> unit into our processor so that it can execute 32-bit variants of\u00a0<code>mul</code> and <code>divu</code> for RISC-V (<code>MUL</code> and <code>DIV</code> for ARMv3). HDL simulation and hardware implementation are both required.</p> <ul> <li>For RISC-V, <code>mul</code> and <code>divu</code>  are available in the Multiply extension instruction set - implement the word (32-bit) versions. There is no <code>DIV</code> instruction in ARMv3, so <code>DIV</code> can be done by cannibalizing <code>MLA</code> instruction. The idea is to just use the format of <code>MLA</code> instruction, but the machine will be doing division instead. This will limit our ability to simulate in Keil assembler though. </li> <li>The destination register should contain quotient. The remainder can be discarded.</li> <li>For RISC-V, <code>divu</code> performs unsigned division. (For ARMv3 assume <code>DIV</code> performs unsigned division.)</li> <li>Since <code>mul</code>/<code>MUL</code> writes only the 32-bit result, there is no difference between signed and unsigned variants.</li> <li>In ARMv3, multiplication instruction can set <code>Z</code> and <code>N</code> flags, but this functionality is not a requirement for Assignment 3.</li> <li>The control unit will need to be modified to generate <code>Start</code> and <code>MCycleOp</code> control signals.</li> <li><code>!Busy</code> can be used as the write enable for the PC. This will stall the processor until the multicycle operation is complete.</li> <li>The datapath should be modified to make the appropriate connections to and from the MCycle unit. We will need a multiplexer and a control signal to combine the outputs from ALU and MCycle.</li> <li><code>div</code> (signed division) <code>mulh</code> variants (upper word) and <code>rem</code> variants (remainder) are not required to be implemented for RISC-V, though it takes very little extra effort (except maybe <code>mulhsu</code>). For ARM implementing instructions that generate 64-bit results (<code>SMULL</code>, <code>UMULL</code>, etc) is not a requirement.</li> <li>We can refer to the ARM Architecture Reference Manual (uploaded on Canvas), page A4-66 for MUL instruction format and page A4-54 for MLA instruction format. </li> </ul>"},{"location":"asst_manuals/Asst_03/Asst_03/#task-3-enhancements-5-points","title":"Task 3: Enhancements (5 points)","text":"<p>Improve the given signed multiplier implemented in step 1 to score points for performance enhancement\u00a0[Post-synthesis simulation; showing on hardware is left to your discretion].</p> <p>Some suggestions for improvement are given below. You need not do all of them. Keep in mind that performance improvement carries only 5 marks, and we will be evaluating only one improvement. The purpose is to incentivize some exploration. However, spending too much time on this is not recommended.</p> <ul> <li>Try different techniques to strike a good trade-off between hardware complexity and the number of cycles required for multiplication (for example, 16 cycles instead of 32 or 16, but with more hardware) - the multiplication implemented in the sample code is very inefficient (intentionally).</li> <li>Use a single adder for multiplication and division within the MCycle unit.\u00a0You could even take it one step further by reusing the same adder from the ALU (thus saving one additional adder, but will take a lot of effort, not worth 5 marks). The latter will need to modify the ports for the MCycle unit.</li> <li>Implement Booth's multiplication algorithm or other efficient algorithms you can find on the internet.</li> <li>DO NOT implement a single cycle multiplier - FPGAs have built in multipliers/DSP units, which are inferred when we use the <code>*</code> operator. This is much more efficient than any array adder based multipliers we can implement, but we don't want to be using it in CG3207.</li> </ul>"},{"location":"asst_manuals/Asst_03/Asst_03/#design-instructions","title":"Design Instructions","text":"<ul> <li>You are required to have your own, comprehensive program to have a convincing demo. Only one assembly language program (and hence one bitstream) will be allowed for demo.</li> <li>If you are using the UART console, you can set the radix to hexadecimal in the 'Display' tab of RealTerm.</li> <li>Remember to use plenty of test cases to make sure your multiplier works as intended. </li> </ul>"},{"location":"asst_manuals/Asst_03/Asst_03/#submission-info","title":"Submission Info","text":"<ul> <li>Assignment 3 will be evaluated in Week 9. The presentation schedule can be found on Canvas.\u00a0</li> <li>Please upload the Assignment 3 files to Canvas by the deadline stipulated (generally, before your lab time), including the following files:<ul> <li><code>.v</code>/<code>vhd</code>\u00a0files you have created/modified [\u00a0RTL Sources, Testbench(es) ]\u00a0</li> <li><code>.bit</code>\u00a0files\u00a0</li> <li><code>.s</code>/<code>.asm</code>\u00a0files (assembly programs)</li> <li><code>.ppt</code>\u00a0or <code>.pdf</code> file - 1 to 4 slides showing performance enhancement techniques you have implemented as task (3) above.</li> </ul> </li> </ul> <p>in an archive with the filename GroupXX_Monday/Friday_Asst3.zip (replace XX with your group number) and upload it to Canvas. One submission per group is sufficient \u2013 if there are multiple submissions, the file with the latest timestamp will be taken as the final submission. Do not\u00a0zip and upload the complete project folder \u2013\u00a0only those files mentioned above should be included.\u00a0The files should be the exact same files that you used for the demo.</p>"},{"location":"asst_manuals/Asst_04/Asst_04/","title":"Assignment 4: (Near) Complete Processor + Pipelining + Bells + Whistles","text":"<p>Final</p> <p>This page is now final. Updates will be minimal, and will be highlighted. </p> <p>Info</p> <p>Assignment 4 involves 2 compulsory tasks and the rest is open-ended.</p> <p>Demonstrate Post-synthesis simulation AND FPGA hardware incorporating all the mandatory and open-ended parts. Use a single assembly program that can be entirely compiler-generated, entirely handcrafted, or a combination of the two. Let your imagination run wild!</p>"},{"location":"asst_manuals/Asst_04/Asst_04/#task-1-implementing-the-remaining-instructions-for-rv32i-5-points","title":"Task 1: Implementing the remaining instructions for RV32I [5 points]","text":"<p>Add support for the following previously unsupported instructions/features mentioned below. They are pretty easy to add at this point and will allow you to run almost all the code generated by a compiler. Please see Using Compiled Code page for more info. However, using hand-coded assembly is perfectly fine too.</p> <p>There is no need to try and craft a program specifically to demonstrate everything below, unlike in the previous labs. The only requirement is to have at least one function call in your program, which will cause <code>jal</code> (<code>call</code>) and <code>jalr</code> (<code>ret</code>) to be emitted by the compiler, unless you do a whole program optimization with GCC.</p> <p>The instructions required are:</p> <ul> <li>DP instructions: <code>xor</code>, <code>xori</code>, <code>slt</code>, <code>sltu</code>, <code>slti</code>, <code>sltiu</code>, <code>slli</code>, <code>srli</code>, <code>srai</code>.</li> <li>Branch instructions: <code>blt</code>, <code>bge</code>, <code>bltu</code>, <code>bgeu</code>, <code>jal</code> (with support for linking: i.e. <code>rd = PC + 4</code>), <code>jalr</code>. </li> <li>Multiply (M) instructions: <code>mulh</code>, <code>mulhu</code>, <code>div</code>, <code>rem</code>, <code>remu</code>. <code>mulhsu</code> is NOT a requirement, as it requires some additional effort. <code>mulhsu</code> can be avoided in the compiler-generated code by avoiding signed x unsigned multiplications.</li> </ul> <p>Support for byte and half-word load / store is NOT a basic requirement. They can be mostly avoided by using only <code>int</code>s in your program. However, incorporating them can lead to easier to write and more efficient programs, especially when using byte-oriented peripherals such as the UART console, 8-bit images with OLED, etc.</p>"},{"location":"asst_manuals/Asst_04/Asst_04/#task-2-pipelining-our-cpu-10-points","title":"Task 2: Pipelining our CPU [10 points]","text":"<p>Implement basic pipelining. Hazard hardware is optional and will count as an open-ended enhancement if done, but it is not counted for the compulsory task points. Pipelining should be done such that the processor supports all the requirements for Assignment 2, Assignment 3, and the additional instructions / features mentioned in Assignment 4 Compulsory Task 1 above.</p> <p>As long as your code works after inserting sufficient <code>nop</code>s, this task requirement can be satisfied. If you have full hazard hardware, of course, <code>nop</code>s are unnecessary.</p> Tips for implementing pipelining <ul> <li>The WE of the PC given in the templates is active high, while the one given in the pipelined design (Chapter 6) is active low. You might want to change the PC WE in the templates to active low to be consistent.</li> <li>Even though the pipeline registers are shown as big registers storing a lot of stuff, each data stored can be thought of as being in a separate register. In other words, in your HDL code, you don't have to try and 'collect' all the bits to form a single register entity.</li> </ul> Increasing the clock speed <p>Now that you have pipelined your processor, you might be able to run it without any clock division, at the full 100 MHz, especially if your program memory and data memory are small. Change <code>CLK_DIV_BITS</code> to 0 to test if this is the case.</p> <p>However, note that even with the standard 5-stage pipeline, 100 MHz may not always be achievable, especially if your memory size is large. Up to ~430 MHz is possible, though very unlikely with a 5-stage pipeline. To increase the clock beyond 100 MHz, you will need to make use of the FPGA's built-in clocking resource called MMCM (which uses phase-locked loops). This can be configured using a clocking wizard (Google for more info).</p> <p>Tips for faster clock speeds:</p> <ul> <li>Identify the bottleneck by looking at the timing report.</li> <li>Use smaller memories.</li> <li>For larger memories, use block ram templates, and allow at least 2 clock edges, and maybe even 3 for a read. This, of course, is a major design change as the pipeline is no longer 5-stage.</li> <li>Use a hierarchy of memories.</li> <li>If the bottleneck is the execute stage, try to make it shorter by moving the PC logic to the M stage.</li> </ul> <p>Now, how do we know what frequency it can run at? You do synthesis and then implementation, and see the warnings. You'll get a critical warning that some timing constraints are not met if the frequency you set cannot be obtained. If you get this warning, the functionality is not reliable even if it runs on the board, and you must either change your design to make it run faster, or change your clock frequency via <code>CLK_DIV_BITS</code> and/or introducing a Clocking Wizard.</p>"},{"location":"asst_manuals/Asst_04/Asst_04/#systematic-procedure-for-pipelining","title":"Systematic procedure for Pipelining","text":"<p>Follow these steps to implement pipelining.</p> <ol> <li> <p>Start by inserting the appropriate suffixes (F/D/E/M/W) for each wire, port, register, and signal. Refer to slide 11 of Chapter 6 for this. For every signal that goes through multiple pipeline stages, it will need to be split into two signals, separated by a pipeline register. Note: Generally, the signals going into every component will have the same suffix, since every component is part of one and only one pipeline stage. The exception to this is the register file, where <code>A3</code> and <code>WD3</code> (ARM) or <code>WD</code> (RISC-V).</p> </li> <li> <p>Make the appropriate datapath connection(s) for every signal going through a pipeline register. Some connections were made implicitly, such as ALUControl. These connections will need to be made explicitly. For RISC-V, a multiplexer must be inserted to select between <code>PC_F</code> and <code>PC_E</code>, controlled by <code>PCSrc_E</code>. Remember to change the datatype from <code>wire</code> to <code>reg</code> where necessary.</p> <ul> <li>Verilog: Use a combinational always block with non-blocking assignments. For example:</li> </ul> <pre><code>always @(*) begin\n    ExtImm_E &lt;= ExtImm_D;\nend\n</code></pre> <p>in ARM.v or RV.v</p> <ul> <li>VHDL: Use a concurrent statement (NOT inslude a clocked process for now). For example, <code>ExtImm_E &lt;= ExtImm_D;</code> in ARM.vhd</li> </ul> </li> <li> <p>Verify that your design works EXACTLY as it did previously, without any changes to the assembly language program. We have NOT yet inferred any registers, so there should not be any pipelining going on (yet!). If something has broken, now is a good time to debug it.</p> </li> <li> <p>Now, we implement the pipeline registers.</p> <ul> <li>VHDL: Move all the signals that are supposed to go through a particular pipeline register into\u00a0one clocked process in ARM/RISC-V architecture\u00a0(everything in one big clocked process is fine too, but it is better to keep it in separate processes for better organization).</li> <li>Verilog: Change the combinational <code>always @(*)</code> to <code>always @(posedge clk)</code>.</li> </ul> </li> <li> <p>Initialize all your signals and registers to zero. Add a condition that sets all these signals and registers to zero when RESET is asserted, and otherwise, assigns the RHS to the LHS at the clock edge.</p> </li> <li> <p>Modify the Register file slightly, to read the clock at negative edges as follows. Alternatively, you can leave it as posedge clk, and insert 3 <code>nop</code>s later instead of 2.</p> <ul> <li>VHDL: <code>CLK'event and CLK='1'</code> becomes <code>CLK'event and CLK='0'</code>.</li> <li>Verilog: <code>always @(posedge clk)</code> becomes <code>always @(negedge clk)</code>.</li> </ul> </li> <li> <p>Your processor should now be pipelined, your old program may not work as it did. You will need to add <code>nop</code>s wherever there is any kind of hazard, to avoid these. For a start, just insert nops such that each pair of instructions having a data hazard is spaced by at least 2 instructions, for example, insert 2 nops if the two instructions are consecutive (or 3 if using the same clock edge). After each branch, insert 2 nops (or more if necessary, depending on which stage the branch is taken).</p> </li> <li> <p>Verify that your design works\u00a0as it used to (it will just be slower because of all the nops).</p> </li> </ol> <p>For hazard resolution hardware (not a basic requirement), follow the design in Chapter 5. Do it systematically and incrementally, one hazard at a time, and testing at each step.</p>"},{"location":"asst_manuals/Asst_04/Asst_04/#task-3-open-ended-enhancement-10-points","title":"Task 3: Open-ended Enhancement [10 points]","text":"<p>This is the fun part - you get 10 points for Assignment 4 for implementing performance enhancements of your choice. There is no fixed requirement to get these points, and while we suggest some enhancements below, it doesn't mean you need to implement all (or any!) of these. Just one significant performance enhancement will suffice, and this need not be limited to the ones we have listed.</p> Idea: Hazard hardware <p>This is somewhat low-hanging fruit. After implementing simple pipelining, you'll probably get very annoyed, very quickly, by having to put <code>nop</code>s in the correct places. And this is before you make a mistake and spend hours debugging a bug caused by too few nops!</p> <p>You may choose to implement something simple that just stalls the processor, or perhaps something more interesting that forwards data when necessary. The complexity of your implementation will decide how well you score. </p> Idea: Additional instructions <p>You may choose to implement some additional instructions for your processor for your enhancement, or features of instructions that have not been fully implemented. The score you get for this will depend on how much additional logic you need to add for these features.</p> Suggestions for RISC-VSuggestions for ARM Idea: Exception handling and interrupt support <p>You can implement some simple interrupt handling. There is no need to conform to the RISC-V interrupt architecture.</p> <p>External interrupt generation logic can be done inside the wrapper fairly easily. For example, if you want an interrupt to be raised when any of the pushbuttons are pressed, you can do interrupt = <code>PB[3] |\u00a0PB[2] |\u00a0PB[1] |\u00a0PB[0]</code>. This interrupt can then be fed into ARM/RV module from the wrapper.</p> <p>Other possible exception/interrupt sources are:</p> <ul> <li>other peripherals - e.g., counter from Wrapper</li> <li>invalid memory address - <code>bad_MEM_addr</code> from the address decoder of Wrapper</li> <li>unaligned address - easy to detect in Wrapper or RV. The additional instructions page has some info on it</li> <li>illegal instruction - from your instruction decoder</li> <li>division by zero - from MCycle</li> </ul> <p>Some other tips:</p> <ul> <li>You can have a hardcoded exception handler address input to the multiplexer controlling the PC input. The interrupt input itself can be used as (part of the) multiplexer select input.</li> <li>You can write your interrupt service routine in your assembly code, figure out the starting address, and use this value as a hardcoded input to the mux. An alternative is to decide on a fixed handler address, and fill up spaces/nops in your code until the handler starts address. For example, if you fix the handler starting address to be 0x100 and your 'main' program contains 30 instructions, you will need to add 34 nops before the first instruction in the handler code so that handler code will indeed be at 0x100.</li> <li>ARM: You should also have some mechanism to save <code>PC+4</code> into a register (say, <code>LR</code> in ARM) and to restore it when the handler has finished (use <code>MOV PC, LR</code> to return from the handler).</li> <li>RISC-V: The address of the instruction that caused the exception/ that was about to be executed when an interrupt came in is saved into epc^ (exception program counter, and not <code>ra</code>). Since we aren't aiming for compliance, saving automatically to another general-purpose register that isn't used in your program is an option too. Saving to <code>ra</code> can be problematic when you have function calls as <code>ra</code> gets overwritten. You can then use <code>jalr</code> aka <code>jr</code> to return from an interrupt.</li> </ul> <p>^ Note that epc is not a register that can be used like a general-purpose register. You need <code>csrr</code> to move its content to a general-purpose register. *   If you wish to have vectored interrupts, you need to associate a number with each interrupt. You need a table/ROM with the starting addresses, which will be indexed by the interrupt number. The output of this ROM is to be fed into the PC multiplexer. The PC multiplexer control signal can be the logical OR of all the interrupt lines.</p> Idea: Branch prediction <p>Branch prediction is a very cool feature you can implement. There are many ways to approach this; a simple scheme is explored in the lecture. More complex and advanced ones are out there, but we will not teach you about them; they're for you to discover for yourself. </p> <p>Do not be afraid to go and read some research papers on branch prediction schemes. Trying to implement something from a paper that has been published can be a very rewarding and educational exercise. </p> Idea: Use other hardware peripherals <p>This is not an improvement in and of itself; however, implementing more peripherals in your design might help you better demonstrate the features of your processor. </p> <p>For example, the Nexys 4 has an onboard microphone - perhaps that can be used to demonstrate DSP capabilities? RGB LEDs? VGA port? USB host? The world is your oyster. </p> <p>Digilent's GitHub repository for the Nexys 4 contains some useful code to help implement these peripherals. </p>"},{"location":"asst_manuals/Asst_04/Asst_04/#rv-implement-half-wordbyte-load-and-store","title":"RV: Implement half-word/byte load and store","text":"<p>You might want to add support for byte and half-word load and store: <code>lb</code>, <code>lh</code>, <code>lbu</code>, <code>lhu</code>, <code>sb</code>, <code>sbu</code>. This can be useful for data memory, all read-only peripherals that have meaningful bytes/half-words, and for 7-segment display.</p> <p><code>ReadData_in</code> is the whole word that contains the word/half-word/byte you want. You need to extract what you want, with a sign/zero(<code>u</code>) extension as required by the instruction. For example, when running <code>lbu</code> (load byte unsigned) instruction, if the last 2 bits of the address is <code>2'b01</code>, and the address location specified in the instruction has <code>8'hAB</code>, <code>ReadData_in</code> is <code>32'hxxxxABxx</code>. <code>ReadData</code>, the word to be written into the destination register is <code>32'h000000AB</code> (0s as MSBs as it is <code>lbu</code>). For <code>lb</code>, <code>ReadData_in[15]</code> should be replicated to the 24 MSBs. You have to do this conversion. This is better done in the W stage in a pipelined processor.</p> <p><code>WriteData_out</code> is a word, with word/byte/half-word aligned to where you wish to write it to within the word. The <code>MemWrite_out</code> bits of every byte to be modified should be 1. For example, when running <code>sb</code> (store byte) instruction, if the last 2 bits of the address is <code>2'b10</code> and the byte to be written is <code>8'hAB</code> (or <code>32'b000000AB</code>), <code>WriteData_out</code> should be <code>32'hxxABxxxx</code> and <code>MemWrite_out</code> should be <code>4'h0100</code>.You have to do this conversion. Another example: when running <code>sh</code> (store halfword), if the last 2 bits of the address is <code>2'b10</code> and the half-word to be written is <code>16'hABCD</code> (or <code>32'h0000ABCD</code>), <code>WriteData_out</code> should be <code>32'hABCDxxxx</code> and <code>MemWrite_out</code> should be <code>4'h1100</code>. You have to do this conversion.</p> <p>CAUTION: Unaligned data reads and writes are NOT supported. If the instruction is <code>lh</code>/<code>lhu</code>/<code>sh</code> (load/store halfword), the data memory address should be divisible by 2 (the last bit should be 0) If the instruction is <code>lw</code>/<code>sw</code>, the data memory address should be divisible by 4 (the last two bits should be 0s)</p> <p>Please read the relevant comments in Wrapper.v carefully.</p> <p>Potential enhancement: Unaligned requests can be detected and used to generate interrupts by editing the wrapper. This interrupt could be used to do a software emulation of unaligned access via aligned access.</p>"},{"location":"asst_manuals/Asst_04/Asst_04/#rv-implement-isa-extensions","title":"RV: Implement ISA extensions","text":"<p>See the RISC-V Specification for ideas. Floating-point, vector and cryptography are potentially interesting ISA extensions. </p>"},{"location":"asst_manuals/Asst_04/Asst_04/#arm-implement-more-dp-instructions","title":"ARM: Implement more DP instructions","text":"<ul> <li>Implement all 16 Data Processing instructions. See Section \"A3.4 Data processing instructions\" in page A3-9 to A3-11 (page 75) of ARM\u00a0Architecture Reference Manual\u00a0for the details of the instructions. Page A3-11 has links to Sections 4.xx, where the instruction behavior is explained in more detail.\u00a0Make sure you look at the ARM (32-bit) instructions, not Thumb (16-bit) instructions.</li> <li>It mainly involves modifying the ALU and the ALU Decoder.</li> <li>The C flag has to be an output from the CondLogic component/module, to act as an input for the ALU component/module (to support ADC instruction).</li> <li>Implement it efficiently, hopefully without additional adders.</li> <li>Support the additional multiplication instructions like <code>SMULL</code> and <code>UMULL</code>. There is not much point in implementing <code>SMLAL</code> and <code>UMLAL</code> since we already cannibalized the <code>MLA</code> instruction for division.</li> <li>Support other instructions like <code>SWP</code> and <code>BL</code>.</li> <li>Support other variants of existing instructions such as pre-indexed and post-indexed <code>LDR</code>/<code>STR</code>, Register Shifted Register Src2, <code>MUL</code> setting <code>Z</code> and <code>N</code> flags, etc.</li> <li>Support Src2 for DP instructions with rotated immediates.</li> <li>You can use the same shifter unit that we have used so far. Just make the appropriate connections.</li> <li>This will need a 32-bit mux at the shifter input, a 1-bit mux for <code>Shamt5[0]</code>\u00a0(which is '0' when\u00a0rot\u00a0is used), as well as a 2-bit mux for sh (which is \"11\" for immediate Src2) - all the muxes can be controlled using the same control signal.</li> <li>An alternative (more hardware efficient) is to move the shifter after the multiplexer controlled by <code>ALUSrc</code> (i.e., to just before SrcB of the ALU), and you can continue to use the same <code>ALUSrc</code> control signal. This will eliminate the need for a 32-bit multiplexer. However, you will need a 5-bit multiplexer for\u00a0Shamt5, with a 2-bit control signal - select <code>Shamt5</code> for register Src2, (<code>Shamt5[4:1], 0</code>) for immediate Src2 and <code>00000</code> for all others. A\u00a02-bit mux for sh will be required too, which selects \"11\" for immediate Src2, sh for register Src2, and either for all others (as the shift amount is zero for others anyway).</li> <li>Your shifter could be modified to generate a carry ('C') based on the last bit that is shifted out (<code>shifter_carry_out</code>). This can be used to set the carry flag for instructions such as <code>MOVS</code>, <code>ANDS</code>, <code>ORRS</code>, etc. (see ARM reference manual for the explanation of <code>MOVS</code>, etc.).</li> <li>This will require <code>FlagW</code> to be used differently (now that 'C' and 'V' are not always written together).</li> <li>Effective 'C' will be instruction-dependent - need more logic to channel the appropriate carry into the input of 'C' flipflop/register. This logic can be inside the ALU (in which case the carry from the shifter will have to be an input to the ALU) or in the main ARM module.</li> </ul>"},{"location":"asst_manuals/Asst_04/Asst_04/#tips","title":"Tips","text":"<ul> <li>You may require additional read/write ports for the register file. You could also use micro-operations to avoid the need for more than 2 read ports / more than two write ports for some of the instructions - you will need additional\u00a0logic to write results one by one over two cycles while PC is stalled. For example, for <code>SMULL</code>, <code>UMULL</code> etc, you can have an internal register (which is not in the visible register set) for storing the second word, to be written in the second cycle. You will also need to generate two sets of control signals - one for the first cycle and one for the second cycle. A multiplexer is required to select one of the two sets of control signals, which are passed to the E pipeline register over successive clock cycles.</li> <li>You don't have to worry about how xPSR is dealt with in the special case of Rd=R15, as mentioned in the manual.</li> <li>Note that when I bit of the instruction is 0, and bits 7 and 4 of the instruction are both 1's, the instruction is not a usual DP instruction (could be <code>MUL</code>, etc.).</li> <li>You can modify the ARM processor to work even for\u00a0<code>LDR PC,..</code> without that much of an effort. If <code>LDR</code> with PC as destination needs to be supported, we need to create a separate signal <code>PCWriteLDR</code> specifically for this case. <code>PCWriteLDRM + PCWriteLDRW</code> should stall D and Flush E., in addition to <code>PCSrcE</code> flushing D and E (effectively, we will be flushing 4 instructions).\u00a0You will need to retain the multiplexer as in the original circuit to enable the result read from the memory to go into the PC. So essentially, you will have 2 multiplexers for PC input - one as in the original branch, and one for early BTA.</li> <li>Forwarding data from W to D will allow you to write the register file at the positive edge, which will most likely reduce your critical path and improve the frequency at which your processor can operate.</li> </ul>"},{"location":"asst_manuals/Asst_04/Asst_04/#design-instructions","title":"Design Instructions","text":"<ul> <li>You are required to have your own, comprehensive programs to have a convincing demo.</li> <li>You may have to tweak the templates given in Assignment 2 for use in Assignment 4. Specifically, you will have to change the <code>ALUControl</code> to 4 bits for ARM, <code>PCSrc</code> and <code>ALUSrcA</code>/<code>B</code> width for RISC-V, etc.</li> <li>All 32-bit combinational arithmetic and logical operations have to be performed inside the ALU. Exceptions: <code>+</code> for calculating <code>PC+4</code>, <code>PC+8</code> (in ARM), multiplication, division, enhancements such as branch prediction.\u00a0Pipeline hazard detection will require comparisons (for equality only) too, but they are on 5-bit values.</li> <li>In the ALU, DO NOT use additional <code>+</code> signs -&gt; this could infer additional adders. The existing addition framework should be good enough.</li> <li>All operators are permitted on 32-bit values outside the ARM/RISC-V module. For example, you will have to do 32-bit comparisons in the wrapper for address decoding.</li> <li>Use of arithmetic operators:<ol> <li>Do not use <code>*</code> operator. It is synthesizable, but in this course, we are implementing multi-cycle multiplication. <code>/</code> is not synthesizable, except on constants.</li> <li>All operators (including <code>**</code>, <code>*</code>, <code>/</code>, <code>sll</code>, <code>rem</code>, <code>mod</code> etc.) are allowed on constants (operations on constants are done at synthesis time, and will not infer any hardware).</li> </ol> </li> </ul>"},{"location":"asst_manuals/Asst_04/Asst_04/#submission-info","title":"Submission Info","text":"<ul> <li>Assignment 4 will be evaluated in Week 12. The presentation schedule can be found on Canvas.</li> <li>Include<ul> <li>.v/vhd\u00a0files you have created/modified [\u00a0RTL Sources, Testbench(es) ]</li> <li>.c/h files used to generate assembly</li> <li>.bit\u00a0files</li> <li>.s/.asm files (assembly programs)</li> <li>.ppt\u00a0file - 2 to 6 slides showing performance enhancement techniques you have implemented.</li> </ul> </li> </ul> <p>in an archive with the filename\u00a0GroupXX_Monday/Friday_Lab4.zip (replace XX with your group number) and upload it to Canvas. One submission per group is sufficient \u2013 if there are multiple submissions, the file with the latest timestamp will be taken as the final submission. Do not\u00a0zip and upload the complete project folder \u2013\u00a0only those files mentioned above should be included.\u00a0The files should be the exact same files that you used for the demo.</p>"},{"location":"asst_manuals/Asst_04/BlockRAM/","title":"Using Block RAMs","text":"<ul> <li>Possible to use block RAMs (sync read) for instruction and data memories in the pipelined version. Allows faster synthesis times and possibly clock rates for larger memory sizes. To use FPGA block RAMs for instruction and data memories in pipelined version (Allows faster synthesis times and possibly clock rates for larger memory sizes): (Disclaimer: Not tested fully). Change to always@(posedge clk) where relevant. Read the comments for more info.  If enabled, Instr, ReadData_in are delayed by 1 cycle. Therefore, what you get can be used as InstrD, ReadDataW directly. MMIO reads are also delayed. Register file outputs are RD1E and RD2E directly if it is done for the register file.</li> </ul>"},{"location":"asst_manuals/Asst_04/additional_instructions/","title":"Enhancement: Implementing additional instructions","text":"<p>You may choose to implement some additional instructions for your processor for your enhancement, or features of instructions that have not been fully implemented. The score you get for this will depend on how much additional logic you need to add for these features.</p>"},{"location":"asst_manuals/Asst_04/additional_instructions/#suggestions-for-risc-v","title":"Suggestions for RISC-V","text":"<ul> <li>Add support for byte and half-word load and store: <code>lb</code>, <code>lh</code>, <code>lbu</code>, <code>lhu</code>, <code>sb</code>, <code>sbu</code>. This can be useful for data memory, all read-only peripherals that have meaningful bytes/half-words, and for 7-segment display.</li> </ul> <p>ReadData_in is the whole word that contains the word/half-word/byte you want. You need to extract out what you want, with sign/zero(<code>u</code>) extension as required by the instruction. For example, when running <code>lbu</code> (load byte unsigned) instruction, if the last 2 bits of the address is 2'b01, and the address location specified in the instruction has 8'hAB, ReadData_in is 32'hxxxxABxx. ReadData, the word to be written into the destination register is 32'h000000AB (0s as MSBs as it is <code>lbu</code>). For <code>lb</code>, ReadData_in[15] should be replicated to the 24 MSBs. You have to do this conversion. This is better done in W stage in a pipelined processor.</p> <p>WriteData_out is a word, with word/byte/half-word aligned to where you wish to write it to within the word. The MemWrite_out bits of every byte to be modified should be 1. For example,when running <code>sb</code> (store byte) instruction, if the last 2 bits of the address is 2'b10 and the byte to be written is 8'hAB (or 32'b000000AB), WriteData_out should be 32'hxxABxxxx and MemWrite_out should be 4'h0100.You have to do this conversion. Another example: when running <code>sh</code> (store halfword), if the last 2 bits of the address is 2'b10 and the half-word to be written is 16'hABCD (or 32'h0000ABCD), WriteData_out should be 32'hABCDxxxx and MemWrite_out should be 4'h1100. You have to do this conversion.</p> <p>CAUTION: Unaligned data reads and writes are NOT supported. If the instruction is <code>lh</code>/<code>lhu</code>/<code>sh</code> (load/store halfword), the data memory address should be divisble by 2 (the last bit should be 0) If the instruction is <code>lw</code>/<code>sw</code>, the data memory address should be divisible by 4 (the last two bits should be 0s)</p> <p>Please read the relevant comments in Wrapper.v carefully.</p> <p>Potential enhancement: Unaligned requests can be detected and used to generate interrupts by editing the wrapper. This interrupt could be used to do a software emulation of unaligned access via aligned access.</p> <ul> <li>Other ISA extensions: see the RISC-V Specification for ideas.</li> </ul>"},{"location":"asst_manuals/Asst_04/additional_instructions/#suggestions-for-arm","title":"Suggestions for ARM","text":"<ul> <li>Implement all 16 Data Processing instructions. See Section \"A3.4 Data processing instructions\" in page A3-9 to A3-11 (page 75) of ARM\u00a0Architecture Reference Manual\u00a0for the details of the instructions. Page A3-11 has links to Sections 4.xx where the instruction behavior is explained in more detail.\u00a0Make sure you look at the ARM (32-bit) instructions, not Thumb (16-bit) instructions.</li> <li>It mainly involves modifying the ALU and the ALU Decoder.</li> <li>The C flag has to be an output from the CondLogic component/module, to act as an input for the ALU component/module (to support ADC instruction).</li> <li>Implement it efficiently, hopefully without additional adders.</li> <li>Support the additional multiplication instructions like <code>SMULL</code> and <code>UMULL</code>. There is not much point in implementing <code>SMLAL</code> and <code>UMLAL</code> since we already cannibalized the <code>MLA</code> instruction for division.</li> <li>Support other instructions like <code>SWP</code> and <code>BL</code>.</li> <li>Support other variants of existing instructions such as pre-indexed and post-indexed <code>LDR</code>/<code>STR</code>, Register Shifted Register Src2, <code>MUL</code> setting <code>Z</code> and <code>N</code> flags, etc.</li> <li>Support Src2 for DP instructions with rotated immediates.</li> <li>You can use the same shifter unit that we have used so far. Just make the appropriate connections.</li> <li>This will need a 32-bit mux at the shifter input, a 1-bit mux for <code>Shamt5[0]</code>\u00a0(which is '0' when\u00a0rot\u00a0is used), as well as a 2-bit mux for sh (which is \"11\" for immediate Src2) - all the muxes can be controlled using the same control signal.</li> <li>An alternative (more hardware efficient) is to move the shifter after the multiplexer controlled by <code>ALUSrc</code> (i.e., to just before SrcB of the ALU), and you can continue to use the same <code>ALUSrc</code> control signal. This will eliminate the need for a 32-bit multiplexer. However, you will need a 5-bit multiplexer for\u00a0Shamt5, with a 2-bit control signal - select <code>Shamt5</code> for register Src2, (<code>Shamt5[4:1], 0</code>) for immediate Src2 and <code>00000</code> for all others. A\u00a02-bit mux for sh will be required too, which selects \"11\" for immediate Src2, sh for register Src2, and either for all others (as the shift amount is zero for others anyway).</li> <li>Your shifter could be modified to generate a carry ('C') based on the last bit that is shifted out (<code>shifter_carry_out</code>). This can be used to set the carry flag for instructions such as <code>MOVS</code>, <code>ANDS</code>, <code>ORRS</code>, etc. (see ARM reference manual for the explanation of <code>MOVS</code> etc.).</li> <li>This will require <code>FlagW</code> to be used differently (now that 'C' and 'V' are not always written together).</li> <li>Effective 'C' will be instruction-dependent - need more logic to channel the appropriate carry into the input of 'C' flipflop/register. This logic can be inside the ALU (in which case the carry from the shifter will have to be an input to the ALU) or in the main ARM module.</li> </ul>"},{"location":"asst_manuals/Asst_04/additional_instructions/#tips-for-arm","title":"Tips for ARM","text":"<ul> <li>You may require additional read/write ports for the register file. You could also use micro-operations to avoid the need for more than 2 read ports / more than two write ports for some of the instructions - you will need additional\u00a0logic to write results one by one over two cycles while PC is stalled. For example, for <code>SMULL</code>, <code>UMULL</code> etc, you can have an internal register (which is not in the visible register set) for storing the second word, to be written in the second cycle. You will also need to generate two sets of control signals - one for the first cycle and one for the second cycle. A multiplexer is required to select one of the two sets of control signals which are passed to the E pipeline register over successive clock cycles.</li> <li>You don't have to worry about how xPSR is dealt with in the special case of Rd=R15 as mentioned in the manual.</li> <li>Note that when I bit of the instruction is 0, and bit 7 and bit 4 of the instruction are both 1's, the instruction is not a usual DP instruction (could be <code>MUL</code> etc.).</li> <li>You can modify the ARM processor to work even for\u00a0<code>LDR PC,..</code> without that much of an effort. If <code>LDR</code> with PC as destination needs to be supported, we need to create a separate signal <code>PCWriteLDR</code> specifically for this case. <code>PCWriteLDRM + PCWriteLDRW</code> should stall D and Flush E., in addition to <code>PCSrcE</code> flushing D and E (effectively, we will be flushing 4 instructions).\u00a0You will need to retain the multiplexer as in the original circuit to enable the result read from the memory to go into PC. So essentially, you will have 2 multiplexers for PC input - one as in the original branch, and one for early BTA.</li> <li>Forwarding data from W to D will allow you to write register file at the positive edge, which will most likely reduce your critical path and improve the frequency at which your processor can operate.</li> </ul>"},{"location":"asst_manuals/Asst_04/interrupts/","title":"Enhancement: Interrupt generation and exception handling","text":"<p>You can implement some simple interrupt handling. There is no need to conform to the RISC-V interrupt architecture.</p> <p>External interrupt generation logic can be done inside the wrapper fairly easily. For example, if you want an interrupt to be raised when any of the pushbuttons are pressed, you can do interrupt = <code>PB[3] |\u00a0PB[2] |\u00a0PB[1] |\u00a0PB[0]</code>. This interrupt can be then be fed into ARM/RV module from the wrapper.</p> <p>Other possible exception/interrupt sources are  * other peripherals - e.g., counter from Wrapper * invalid memory address - <code>bad_MEM_addr</code> from the address decoder of Wrapper * unaligned address - easy to detect in Wrapper or RV. The additional instructions page has some info on it * illegal instruction - from your instruction decoder * division by zero - from MCycle</p> <p>Some other tips: * You can have a hardcoded exception handler address input to the multiplexer controlling the PC input. The interrupt input itself can be used as (part of the) multiplexer select input. *   You can write your interrupt service routine in your assembly code, figure out the starting address, and use this value as hardcoded input to the mux. An alternative is to decide on a fixed handler address, and fill up spaces/NOPs in your code until the handler starts address. For example, if you fix the handler starting address to be 0x100 and your 'main' program contains 30 instructions, you will need to add 34 NOPs before the first instruction in the handler code so that handler code will indeed be at 0x100. *   ARM: You should also have some mechanism to save <code>PC+4</code> into a register (say, <code>LR</code> in ARM) and to restore it when the handler has finished (use <code>MOV PC, LR</code> to return from the handler). *  RISC-V: The address of the instruction that caused the exception/ that was about to be executed when an interrupt came in is saved into epc^ (exception program counter, and not <code>ra</code>). Since we aren't aiming for compliance, saving automatically to another general purpose register that isn't used in your program is an option too. Saving to <code>ra</code> can be problematic when you have function calls as <code>ra</code> gets overwritten. You can then use <code>jalr</code> aka <code>jr</code> to return from interrupt.  ^ Note that epc is not a register that cannot be used like a general purpose register. You need <code>csrr</code> to move its content to a general purpose register. *   If you wish to have vectored interrupts, you need to associate a number with each interrupt. You need a table/ROM with the starting addresses, which will be indexed by the interrupt number. The output of this ROM is to be fed into the PC multiplexer. The PC multiplexer control signal can be the logical OR of all the interrupt lines.</p>"},{"location":"asst_manuals/Asst_04/pipeline/","title":"Implementing Pipelining","text":"<p>This page will guide you through how to implement basic pipelining for the mandatory task for Lab 4.</p>"},{"location":"asst_manuals/Asst_04/pipeline/#notes","title":"Notes","text":"<ul> <li>The WE of the PC given in the templates is active high, while the one given in the pipelined design (Chapter 6) is active low. You might want to change the PC WE in the templates to active low to be consistent.</li> <li>Even though the pipeline registers are shown as big registers storing a lot of stuff, each data stored can be thought of as being in a separate register. In other words, in your HDL code, you don't have to try and 'collect' all the bits to form a single register entity.</li> </ul>"},{"location":"asst_manuals/Asst_04/pipeline/#systematic-procedure-for-pipelining","title":"Systematic procedure for Pipelining","text":"<p>Follow these steps to implement pipelining.</p> <ol> <li> <p>Start by inserting the appropriate suffixes (F/D/E/M/W) for each wire, port, register, and signal. Refer to slide 11 of chapter 6 for this. For every signal that goes through multiple pipeline stages, it will need to be split into two signals, separated by a pipeline register. Note: Generally, the signals going into every component will have the same suffix, since every component is part of one and only one pipeline stage. The exception to this is the register file, where <code>A3</code> and <code>WD3</code> (ARM) or <code>WD</code> (RISC-V).</p> </li> <li> <p>Make the appropriate datapath connection(s) for every signal going through a pipeline register. Some connections were made implicitly, such as ALUControl. These connections will need to be made explicitly. For RISC-V, a multiplexer must be inserted to select between <code>PC_F</code> and <code>PC_E</code>, controlled by <code>PCSrc_E</code>. Remember to change the datatype from <code>wire</code> to <code>reg</code> where necessary.</p> </li> <li> <p>Verilog: Use a combinational always block with non-blocking assignments. For example:</p> </li> </ol> <pre><code>always @(*) begin\n ExtImm_E &lt;= ExtImm_D;\nend\n</code></pre> <p>in ARM.v or RV.v</p> <ul> <li> <p>VHDL: Use a concurrent statement (NOT inslude a clocked process for now). For example, <code>ExtImm_E &lt;= ExtImm_D;</code> in ARM.vhd</p> </li> <li> <p>Verify that your design works EXACTLY as it did previously, without any changes to the assembly language program. We have NOT yet inferred any registers, so there should not be any pipelining going on (yet!). If something has broken, now is a good time to debug it.</p> </li> <li> <p>Now, we implement the pipeline registers.</p> </li> <li> <p>VHDL: Move all the signals that are supposed to go through a particular pipeline register into\u00a0one clocked process in ARM/RISC-V architecture\u00a0(everything in one big clocked process is fine too, but it is better to keep it in separate processes for better organization).</p> </li> <li> <p>Verilog: Change the combinational <code>always @(*)</code> to <code>always @(posedge clk)</code>.</p> </li> <li> <p>Initialize all all your signals and registers to zero Add a condition that sets all these signals and registers to zero when RESET is asserted, and otherwise, assigns the RHS to the LHS at the clock edge.</p> </li> <li> <p>Modify the Register file slightly, to read the clock at negative edges:</p> </li> <li> <p>VHDL: <code>CLK'event and CLK='1'</code> becomes <code>CLK'event and CLK='0'</code>.</p> </li> <li> <p>Verilog: <code>always @(posedge clk)</code> becomes <code>always @(negedge clk)</code>.</p> </li> <li> <p>Your processor should now be pipelined, your old program may not work as it did. You will need to add <code>NOP</code>s wherever there is any kind of hazard, to avoid these. For a start, just insert NOPs such that each pair of instructions having a data hazard is spaced by at least 2 instructions (for example, insert 2 NOPs if the two instructions are consecutive). After each branch, insert 4 NOPs.</p> </li> <li> <p>Verify that your design works\u00a0as it used to (it will just be slower because of all the NOPs).</p> </li> </ul> <p>For hazard resolution hardware (not a basic requirement), follow the design in Chapter 5. Do it systematically and incrementally, one hazard at a time, and testing at each step.</p>"},{"location":"asst_manuals/Asst_04/pipeline/#increasing-the-clock-speed","title":"Increasing the clock speed","text":"<p>Now that you have pipelined your processor, you might be able to run it without any clock division, at the full 100 MHz, especially if your program memory and data memory are small. Change <code>CLK_DIV_BITS</code> to test if this is the case.</p> <p>However, note that even with the standard 5-stage pipeline, 100 MHz may not always be achievable, especially if your memory size is big. Up to ~430 MHz is possible though unlikely with a 5-stage pipeline. To increase the clock beyond 100 MHz, you will need to make use of the FPGA built-in clocking resource called MMCM (which uses phase-locked loops). This can be configured using a clocking wizard.</p> <p>Tip for faster clock speeds: Identify the bottleneck by looking at that timing report.</p> <ul> <li>Use smaller memories.</li> <li>For larger memories, use block ram templates, and allow at least 2 clock edges, and maybe even 3 for a read. This of course is a major design change as the pipeline is no longer 5 stage</li> <li>Use a hierarchy of memories.</li> <li>If the bottleneck is the execute stage, try to make it shorter by moving the PC logic to M stage.</li> </ul>"},{"location":"code_templates/Asst_02/Optional_Stuff/Readme/","title":"Readme","text":"<ul> <li> <p>All programs here are non-essential.</p> </li> <li> <p>Choose the correct test_Wrapper_variant depending on the .asm/C programme you are using.</p> </li> <li> <p>HelloWorld.asm uses only instructions implemented by Assignment 2.</p> </li> <li> <p>Others require instructions beyond what is required to be implemented in Assignment 2.</p> </li> <li> <p>TOP_Circle_delay_accel_Nexys4*.bit is a prebuilt bitstream corresponding to the Circle_delay_accel program.</p> </li> </ul>"},{"location":"getting_started/howto/","title":"How to use this website","text":""},{"location":"getting_started/howto/#how-to-get-help","title":"How to get help","text":"<p>If you have any questions regarding the content of any of the labs, please follow these steps, in this order, to answer them.  </p> <ol> <li> <p>Please read the lab manual closely. We will try our best to keep the manual updated with any common errors, or issues, that you may face.</p> </li> <li> <p>If the lab manual does not answer your question, the lab repository has a discussions page. Please search here for your question, in case it has already been answered before. We will leave questions and answers from previous semesters on this page, so over time, more and more information should be covered between here and the manuals.</p> </li> <li> <p>If you cannot find an answer to your question in the discussions either, then please create a new discussion. Make sure your title is as succinct, but descriptive, as possible, for the benefit of others who may search the issues page later. Also, do make sure you include all relevant details in the discussion content. This webpage offers some helpful advice on how to ask good technical questions.</p> </li> <li> <p>Please DO NOT send emails to the teaching staff asking technical questions regarding the lab activities. We will ignore all such emails, with no exception. Post all technical questions to the discussions page. This benefits others, because anyone who has the issue in the future can solve it quickly with a search. It also benefits you, because you may receive an answer faster from a classmate, than from us.</p> </li> </ol> <p>On that subject, please do join in and help each other out in the discussions as far as possible.</p>"},{"location":"getting_started/howto/#conventions","title":"Conventions","text":"<p>Note</p> <p>Notes are used to provide extra information that may not be necessary, but hopefully interesting. These are not required knowledge. </p> <p>Tip</p> <p>Tips are used to provide useful information that may make your life easier when using the tools and devices. We recommend reading and remembering these. </p> <p>Info</p> <p>Info panels provide some information about the content in the page. For example, lab manuals with an associated graded assignment use an Info panel at the top to remind you that they are, in fact, graded. </p> <p>Warning</p> <p>Warnings are used for important information that, if disregarded, may likely cause you problems. These may be common mistakes or pitfalls, or reminders to be careful. In this course, these will not have implications for your physical safety... probably. </p> <p>Question</p> <p>Questions are used to indicate questions you must answer in your lab report. </p>"},{"location":"getting_started/nexys4/","title":"Getting to know your Nexys 4 board","text":"<p>Info</p> <p>This page is required reading before, or immediately after, receiving your Nexys 4 or Nexys 4 DDR FPGA board. </p> <p>In this course, you will use a Field Programmable Gate Array (FPGA) development board to learn digital design. We will loan you Nexys 4 boards; emails will be sent to inform you on how to collect the kits.</p> <p>Here is the Digilent reference page for your Nexys 4, or Nexys 4 DDR. You can learn more about the specifications of the boards, and download relevant files.</p>"},{"location":"getting_started/nexys4/#getting-familiar-with-the-board","title":"Getting familiar with the board","text":"<p>The large chip at the center of your board is the FPGA itself. It is the main component of the board, and indeed, the reason why it costs as much as it does. You will learn what an FPGA is in the first lab session.</p> <p>The Nexys 4 boards come with a wide array of peripherals you can use to do all sorts of cool things. The simplest, and the ones we will use in this course, are the 7-segment displays (below the FPGA chip). Below the 7-segment display is an array of 16 LEDs, and below that, in turn, is an array of 16 switches. To the right of the FPGA, there are five black and two red push buttons. The black ones are designed to be general-purpose, and we can use them as inputs in our designs. The red buttons are meant to be used to reset the FPGA or a CPU design on it.</p> <p>The Nexys 4 uses a micro USB connector on the top left of the board, for power, programming, and USB UART interfacing. The kits include a black cable to connect the board to your computer. It also includes a variety of other ports and connectors such as an RJ45 Ethernet jack, a VGA port and a USB port for peripherals like keyboards.</p> <p>Tip</p> <p>If you own a computer with only USB-C ports, then you will need an adapter. Remember to bring one with you to the labs.</p> <p>The single switch at the top left of your board, between the power connector and the full-sized USB-A port, is a power switch. Slide it up to turn the board on.</p>"},{"location":"getting_started/nexys4/#board-handling-guidelines","title":"Board Handling Guidelines","text":"<p>Like most development boards and PCBs, your FPGA board is fragile. Treat it with care and respect, as if it were your own. It is reasonably expensive at over S$500, and not so easy to get replaced.</p> <p>Here are some tips to take good care of your board:</p> <ul> <li>Do not touch the PCB tracks, or the components on the board. Static discharge can damage or destroy electronic components, and these boards can be particularly susceptible.</li> <li> <p>Use the nice plastic box with foam lining to transport your FPGA board. Do not use a plastic bag or other plastic container to carry your boards, and most certainly don't put it bare in your backpack/tote/briefcase/whatever you bring to class.</p> </li> <li> <p>When using the board, keep it on a stable, flat surface. Do NOT have it hanging off the USB cable, or hanging off the edge of a table, or on your lap, or anywhere that isn't a suitable, solid surface.</p> </li> <li> <p>Do not leave your board inside the box while using it plugged in. Anti-static foam can be conductive and short circuit the PCB, potentially damaging or destroying your FPGA board. </p> </li> <li> <p>Absolutely DO NOT DROP your board. When moving it around, hold the board by the edges and make sure the USB cable is unplugged so as to minimize strain on the port and to avoid it getting caught on something.</p> </li> <li> <p>Avoid plugging and unplugging the micro-USB cable more than necessary. To reset the board, you can use the power switch on the top left of the board, or unplug the USB-A connector from your computer if really necessary. Micro USB is a notoriously fragile connector, and it's best to avoid putting more strain on it than necessary. USB-A is much sturdier so that end of the cable is not as much of a concern.</p> </li> <li> <p>Apply common sense and standard practices for taking care of electronics: don't eat or drink near your board in case you get crumbs (or worse, a spill) on the board. Don't throw the board around. Plug and unplug accessories with care. Be gentle when using the switches and buttons.</p> </li> </ul>"},{"location":"getting_started/prereq/","title":"Prerequisites for lab work","text":""},{"location":"getting_started/prereq/#knowledge-and-skills-expected","title":"Knowledge and skills expected","text":"<p>This course is designed for students with a reasonably solid background in digital design and computer organization.</p> <p>The official course prerequisites are CG2028 or EE2028. However, EE2026 (Digital Design) will be a strong plus, too.</p> <p>If you are coming from CS2100DE - first of all, welcome back! Remembering most of CS2100DE will be more than sufficient for this course.</p> <p>Preparation is the key to success</p> <p>The labs for this course constitute a large percentage of your final grade (40%!), and not knowing how to design for an FPGA will make your life unnecessarily difficult.</p> <p>If you haven't taken, or don't remember very well, the content from either CS2100DE or EE2026 - we highly, highly, highly recommend (did I mention we highly recommend?) working through the manuals for labs 1 through 4 from CS2100DE. We recommend working through these in the first 3 weeks of the semester, before starting the CG3207 labs.</p> <p>If you are an official student for the course, drop the teaching team an email, and we will do our best to let you borrow a Nexys 4 FPGA board early, so you can work through the aforementioned labs.</p>"},{"location":"getting_started/prereq/#hardware-required","title":"Hardware required","text":"<p>For this course, you will need an FPGA development board. We will provide you a Nexys 4 board, and our materials will expect you to use this specific board. You will also need a Windows or Linux (preferred) computer to run the software to program this FPGA. The PCs in the lab will have the software required for this course installed for you, and you may use these as well.</p> <p>Note</p> <p>If you are not an official student of this course, and do not have access to a Nexys 4 board to follow along, you can use any other Xilinx/AMD FPGA development board, like the Basys 3 or Arty A7. You may need to make some changes to your code and project files to account for the different FPGA and different available peripherals. You may also be able to use a completely different brand of FPGA, like an Intel or Sipeed board. However, you will not be able to use Vivado, nor our template files.</p> <p>The FPGA board comes with a USB type A to USB micro-B cable. You will need a USB type A port on your laptop, and if you do not have one, you must use an adapter. Remember to bring one to class.</p>"},{"location":"getting_started/prereq/#software-required","title":"Software required","text":"<p>The software you will use to program your FPGA board is Vivado. Installation instructions can be found here. Please install Vivado before coming for your first lab in Week 4.</p> <p>To explore RISC-V assembly, we will use the RARS architecture simulator. This runs on Windows, macOS and Linux, and does not require any installation and can be run by double clicking the downloaded jar file or by running <code>java -jar filename.jar</code> where <code>filename</code> is the name of the jar file you downloaded.</p> <p>Note</p> <p>If you choose to implement the ARM architecture for your project, you will need to use ARM's (somewhat antiquated) Keil MDK 4. Instructions to use this IDE are available on the page about ARM programming.</p>"},{"location":"getting_started/vivado_install_guide/","title":"Installation Guide for Vivado","text":"<p>Warning</p> <p>Please note that this is the CG3207 website. If you are taking a different course, you may have been directed here for the instructions to install Vivado. </p> <p>Please DO NOT get confused, and start doing the labs for CG3207, if you are not taking CG3207. </p> <p>For this course, we recommend using Vivado 2023.2. Any other version of Vivado you have installed will probably work; however, you will need support for 7 series FPGAs to be able to use the Nexys 4 board. </p> <p>Note</p> <p>Vivado runs on Windows and Linux, but not on macOS. However, we have recently found that it is possible to run Vivado on a Mac computer using Parallels Desktop. Our test setup was as follows:</p> <ul> <li>MacBook Pro with M1 Max CPU</li> <li>macOS Sequoia version 15.4</li> <li>Parallels Desktop Pro version 20.2.2, running Windows 11</li> </ul> <p>Download and install Parallels Desktop. Create a virtual machine for Windows 11 on Parallels Desktop, then in that VM, follow the steps for Windows in this guide. To successfully connect your FPGA board to Vivado, you will need to install the latest version of the Digilent Adept Runtime, as the cable drivers included with Vivado may not install correctly. </p> <p>If you are an NUS student, you may obtain a license for Windows 11 Education from here. </p> <p>We have not (yet) tested Vivado running on a Linux VM (e.g. Ubuntu on Parallels), or using other hypervisors (e.g. VMWare Fusion, QEMU etc.). These setups may work, but are not guaranteed to do so. We understand Parallels Desktop is paid (and not cheap) software, so if you are unable to obtain a license to use it, we recommend either borrowing a laptop/PC from someone you know, or using the lab PCs which have the software preinstalled.</p> <p>Download Vivado from AMD/Xilinx's website. We echo AMD's recommendation to download the web installer instead of the full, 100+ gigabyte archive. Download the exe or bin file, depending on your operating system of choice. </p> <p>You will need to create an account to download Vivado and fill out a form for US export control regulations. You will also need to enter this information when you install the software. </p>"},{"location":"getting_started/vivado_install_guide/#preparing-to-install-vivado","title":"Preparing to install Vivado","text":""},{"location":"getting_started/vivado_install_guide/#windows","title":"Windows","text":"<p>You should be running Windows 10 or 11. Xilinx recommends the Pro or Enterprise version of certain specific versions of Windows; however, Vivado runs just fine on any version of 10 or 11. Simply open the downloaded executable file. Make sure you allow it through your firewall when prompted, and note that it may show up as \"OpenJDK Platform Binary\" executable requesting permission. </p>"},{"location":"getting_started/vivado_install_guide/#linux-ubuntu-rhel-etc","title":"Linux (Ubuntu, RHEL, etc.)","text":"<p>To install Vivado on Linux, you may first need to install some dependencies. On Ubuntu, these are <code>libtinfo5</code> and <code>libncurses5</code>. Install these with <code>sudo apt install libtinfo5 libncurses5</code>. Some googling will find you the equivalent packages and commands for other distributions like Red Hat/Fedora and Arch. Xilinx officially supports some specific versions of RHEL, CentOS, SLE, Amazon Linux, AlmaLinux and Ubuntu; however, Vivado will probably run on other distributions like Fedora or Arch. </p> <p>Additionally, for Linux, the installer will not automatically install cable drivers for you. After you install Vivado, you must follow the following steps:</p> <p><pre><code># change directory to your Vivado install, for example:\ncd /opt/Xilinx/Vivado/2019.2\n\n# cd into the drivers directory (the script MUST be run there)\ncd data/xicom/cable_drivers/lin64/install_script/install_drivers\n\n# run the cable installer with root privileges\nsudo ./install_drivers\n</code></pre> These steps can also be found on Xilinx support.</p> <p>To run the installer, first use <code>chmod u+x filename.bin</code> to add execute permissions to the downloaded bin file. Remember to replace \"filename\" with the name/path of the downloaded file. Run it using <code>sudo ./filename.bin</code>. </p>"},{"location":"getting_started/vivado_install_guide/#_1","title":"Installation Guide for Vivado","text":"<p>The installer may ask you to install the latest version of Vivado instead. </p> <p></p> <p>Ignore this and click \"Continue\" instead. </p> <p>This will bring you to the Welcome page of the installer, shown below. </p> <p></p> <p>Click \"Next\" to proceed. </p> <p>The installer will now prompt you to enter your username and password you created to authenticate the download. </p> <p></p> <p>Enter your username and password you just created. Make sure you have \"Download and Install Now\" selected. Click \"Next\". </p> <p>You will now see the following screen, asking you which product you would like to install:</p> <p></p> <p>Here, choose Vivado. You will not need Vitis for this course; however, it will be needed for EE4218 and CEG5203, so if you intend to take either course in the future, select Vitis instead. Click \"Next\". </p> <p>Next, you will be prompted for which edition of Vivado you want to install. This prompt will not appear if you chose to install Vitis instead. </p> <p></p> <p>Here, choose the Vivado ML Standard edition. Beware that Vivado ML Enterprise is selected by default. </p> <p>Now, you will be prompted to choose which components you want to install. If you are installing only Vivado for CG3207, then make the following selections: </p> <p></p> <p>Make sure Artix-7 (under the 7 Series devices), and the \"Install Cable Drivers\" option, are checked. </p> <p>If you are installing Vitis, and want to install the components you will need later, make the following selections:</p> <p></p> <p>Make sure Artix-7 (under the 7 Series devices), and Zynq UltraScale+ MPSoC (under the SoCs) are checked, as well as \"Install Devices for Kria SOMs and Starter Kits\". Also make sure \"Install Cable Drivers\" is selected. </p> <p>Click \"Next\" to proceed. You will now be prompted to accept the license agreements for all the products you are installing. </p> <p></p> <p>Check all the \"I Agree\" checkboxes, and click \"Next\" again.</p> <p>The last screen will prompt you for the installation destination and other options. You may choose to stick with the defaults, or change these as per your preference. </p> <p></p> <p>Click \"Next\" here. The installer will then prompt you to confirm your selections.</p> <p></p> <p>Make sure all the options shown are correct for what you're trying to install. Click Install and let the installer run, it may take a while (up to a couple of hours). </p>"},{"location":"getting_started/vivado_install_guide/#next-steps","title":"Next Steps","text":"<p>You may wish to see the Getting Started manual which teaches you some of the basics of how to use Vivado and Verilog to create a design for an FPGA. </p>"},{"location":"rv_resources/peripherals/","title":"Advanced Peripherals","text":""},{"location":"rv_resources/peripherals/#uart","title":"UART","text":""},{"location":"rv_resources/peripherals/#uart-details","title":"UART Details","text":"<p>In the following lines, 'read's and 'write's are from the perspective of the RISC-V\u00a0processor (assembly language program), and act as 'console in' and 'console out' respectively.</p> <ul> <li>Read from the UART_RX only if\u00a0the LSBit of UART_RX_VALID is set. Similarly, write to the UART_TX only if the LSBit UART_TX_READY is set (not very important if the processor runs on a slow clock).</li> <li>Successive writes to the\u00a0UART (<code>sw</code> / <code>STR</code>\u00a0followed by\u00a0<code>sw</code> / <code>STR</code>, i.e.,\u00a0consecutive\u00a0<code>sw</code>s / <code>STR</code>s in your assembly language program) are not supported. Similarly, successive reads (consecutive\u00a0<code>lw</code>s / <code>LDR</code>s) are not supported.</li> <li> <p>Allow sufficient time for the program to read a character before sending the next character from RealTerm. Any character received while one character is waiting to be read would be ignored.\u00a0This shouldn't be a problem if your processor runs at high speed (CLK_DIV_BITS is low).</p> </li> <li> <p>A 32-bit number can be sent as hexadecimal in ASCII format (8 characters), which will require some processing in your program before it can be used as a 32-bit operand (note : '0' is 0x30 and 'A' is 0x41 in ASCII). It is a good idea to echo characters so that you can check whether UART has received it correctly.\u00a0Also, note that backspace doesn't\u00a0work to 'delete' the sent characters unless you implement such a functionality explicitly in your assembly language program.</p> </li> <li> <p>If you use a console, some parts of your program could be repetitive, best implemented using a subroutine. A subroutine is normally implemented using a <code>BL</code>/<code>jal</code> instruction which we have not implemented. A workaround can be seen in the HelloWorld program for Lab 2.</p> </li> <li> <p>In the simulation with UART, setting radix to ASCII could help.</p> </li> <li>Read the instructions in Wrapper.v/vhd before using it.</li> </ul>"},{"location":"rv_resources/peripherals/#realterm-terminal-for-uart","title":"Realterm - Terminal for UART","text":"<p>Realterm\u00a0is an amazing serial monitor program, which could be very useful. You can use this\u00a0for sending and receiving data through the UART console. Teraterm (used in EE2028) is fine too, just that RealTerm is TeraTerm on steriods. RealTerm needs .NET framework\u00a0to be installed.</p> <p></p> <p>Note : The baud rate used depends on the baud rate set in TOP.vhd. In the template provided, it is 115200.</p> <p></p> <p>Figure 1(a) and 1(b) : Screenshot illustrating RealTerm settings.</p> <p>RealTerm allows you to send and display data that is not necessarily ASCII. Sending and receiving raw bytes can be very useful. In fact, it is THE most effective way to get data in/out of the system.  </p> <p>(to do: Provide a screenshot here illustrating sending bytes, and perhaps even an example assembly language program).</p>"},{"location":"rv_resources/peripherals/#oled","title":"OLED","text":"<p>OLED uses PMOD B.</p> <p>The OLED controller has a built-in buffer, which means that your program does not have to keep feeding pixels continuously. Only changes need to be written.  </p> <p>Caution: Do not leave OLED on for too long unnecessarily, especially with the same frame. It can cause burn-in.  </p> <p>OLED_CTRL register functionality is described below.  </p> <p>OLED_CTRL[3:0] : Change that triggers write. We can vary one of them (e.g., column) while keeping the other two the same. This can be efficient in applications like  vector graphics, where replicating a pixel along a row or column is common. In the example program where a line with a specified colour is drawn, we vary only x (columns).</p> <ul> <li>0x0: vary_pixel_data_mode</li> <li>0x1: vary_col_mode (x)</li> <li>0x2: vary_row_mode (y)</li> <li>0x4: autoadvance_col (row major)</li> <li>0x5: autoadvance_row (column major)</li> </ul> <p>Autoadvance mode is similar to vary_pixel_data_mode, but automatically increments row/column indices in a row-major/column-major manner with appropriate wrapping of row/column boundaries and incrementing to the next column/row in hardware. It can accelerate the loading of raster images - the data can simply be streamed in; one write per pixel will suffice. We can feed data from a C array in a 1-D manner without maintaining separate row/column indices. Please note that this feature is experimental, the implementation/code isn't that structured.</p> <p>OLED_CTRL[7:4] : Colour format.</p> <ul> <li>0x0: 8-bit colour mode: 1 byte per pixel, memory efficient especially if loading bitmapped images. Format: 3R-3G-2B.</li> <li>0x1: 16-bit colour mode: Highest colour depth supported by the OLED in a compact representation. It is the OLED native input format: 5R-6G-5B.  </li> <li>0x2: 24-bit colour mode: Similar to standard displays, but some LSBs are not used. Easier to visualise in simulation as each colour is a 2-hex digits. Wrapper output format: 5R-3(0)-6G-2(0)-5B-3(0).  </li> </ul>"},{"location":"rv_resources/peripherals/#loading-images","title":"Loading Images","text":"<p>The easiest way to load a raster image is to hard-code the array in C or assembly. This can be done easily using an online tool such as https://notisrac.github.io/FileToCArray/. Settings for the tool is as below.  Image Conversion Settings. </p> <p>Use Palette mode according to the colour format you desire, which has to be consistent with your choice of OLED_CTRL[3:0]. Resize should be chosen according to the orientation you desire - 64x96 for landscape.</p> <p>It is also possible to receive the image at runtime via UART or initialise it in your HDL via a .mem file. However, these will limit your ability to simulate in RARS.</p> <p>Before you think of loading a raster image - Make sure your data memory is big enough to hold the image. Adjust the depth/size in both HDL and C! A not-too-complex vector image may not need a memory size increase or memory configuration change.</p> <p>A full-resolution image with even 8-bit colour mode requires 6144 bytes, which means a <code>DMEM_DEPTH_BITS</code> of at least 13! The C code <code>DMEM_SIZE</code> should be 2^<code>DMEM_DEPTH_BITS</code> which is 0x2000 for <code>DMEM_DEPTH_BITS</code> of 13 in <code>Wrapper.v</code></p> <p>When you export byte arrays in the data segment from Godbolt to RARS, there could be an issue - RARS doesn't recognize the octal escape sequence emitted by compilers. A workaround is to copy-paste the actual C array into the data segment of RARS with a <code>.byte</code> declaration, instead of using the <code>.ascii</code> array emitted by the compiler. The rest of the generated assembly is fine. This is illustrated in the figures below.  </p> <p> C Code  </p> <p> Octal array emitted by the compiler  </p> <p> Copy-pasted array fix in RARS with <code>.byte</code> declaration</p>"},{"location":"rv_resources/peripherals/#food-for-thought","title":"Food for thought","text":"<ul> <li>It may be better to use synchronous read and use block RAMs if you have many images. Else, you will quickly run out of LUTs.</li> <li>Image pixels being sent column-wise is advantageous if the conversion tool can give a column-major format for the array. This is because multiplication by 64 is easier than by 96.</li> <li>Clang emits <code>mul</code> instructions when you multiply by 96, GCC does y*64+y*32 instead in some optimization modes.</li> <li>It is not uncommon to allocate memory that is larger than the required size to make the buffer dimensions powers of two - trading off memory for performance!</li> <li>It is not possible to read back\u00a0what you wrote to the OLED. Something =\u00a0*OLED_DATA_ADDR does not work. These are memory-mapped peripherals; do not treat like memory. However, it is possible to modify the Wrapper and TOP to accomplish this, but has some hurdles such as needing 2 clock cycles for a read.</li> </ul>"},{"location":"rv_resources/peripherals/#accelerometer","title":"Accelerometer","text":"<p>The accelerometer gives the temperature and X, Y, Z accelerations. ACCEL_DATA is a 32-bit value packing 4 independent 8-bit values  MSB downto LSB. Each value is in 8-bit signed format with a range of +/- 2g. So a reading of 1g is 0x40 and -1g is 0xC0. The sensor in fact gives a 12-bit reading, but uses only 8 bits for simplicity. The calibration is not perfect on all boards, so do not be surprised if there is a fixed offset to all your readings.   <p>If you want only a specific axis or temperature, use a combination of logical operators and shift e.g., extract Y using (*ACC_DATA_ADDR &amp; 0x0000FF00) &gt;&gt; 8. If your processor can do <code>lbu</code>, the required byte can be read directly.  </p> <p>ACCEL_DREADY indicates data readiness, which is useful only when attempting to read at a high rate.</p>"},{"location":"rv_resources/peripherals/#cycle-counter","title":"Cycle Counter","text":"<p>Cycle counter gives the number of processor cycles that have elapsed since the last reset. Cycle counter rolls over at 42 seconds at 100 MHz (CLK_DIV_BITS = 0), but is much longer at lower frequencies. Change counter width and bits used in Wrapper for a longer duration, but lower cycles precision.  </p>"},{"location":"rv_resources/rv_memmap/","title":"RISC-V Memory Map","text":""},{"location":"rv_resources/rv_memmap/#memory-map-of-our-risc-v-processor","title":"Memory Map of OUR RISC-V Processor","text":"<p>Assuming default memory configuration, <code>IROM_DEPTH_BITS</code> = <code>DMEM_DEPTH_BITS</code> = 9.</p> Address Attributes Name DESCRIPTION 0x00400000 to 0x004001FC RO (Read Only) Instruction memory (IROM) 128 words (0x200 bytes) - total number of instructions should not exceed this (127 excluding the last line 'halt B halt'). Word addressable - only multiples of 4 are valid addresses. This might cause warnings about 2 unused bits, but that's ok. 0x10010000 to 0x100101FC RW (Read-Write - See notes below) Data memory (DMEM) 128 words (0x200 bytes) - Total number of constants+variables should not exceed this. Word addressable - only multiples of 4 are valid addresses. 0xFFFF0000 RO UART_RX_VALID Data can be read from UART_RX (is valid) only when the LSBit of this register is set. 0xFFFF0004 RO UART_RX UART Receive (input, from keyboard). UART Settings : Baud Rate 115200. 8-bit. No Parity. 1 Stop bit. Only LSByte is valid.\u00a0RealTerm is a good console application. 0xFFFF0008 RO UART_TX_READY Data can be written to UART_TX only when the LSBit of this register is set 0xFFFF000C WO (Write Only) UART_TX UART Transmit (output, to display). Only LSByte is writeable.\u00a0Same settings as RX 0xFFFF0020 WO OLED_COL The OLED pixel column index, between 0 and 95. 0xFFFF0024 WO OLED_ROW The OLED pixel row index, between 0 and 63. 0xFFFF0028 WO OLED_DATA Please see the peripherals page for details on choosing OLED data format via OLED_CTRL register. 0xFFFF002C WO OLED_CTRL Controls OLED data format and modes of operation. 0xFFFF0040 RO ACCEL_DATA Please see the peripherals page for details on accelerometer data format. 0xFFFF0044 RO ACCEL_DREADY A new reading is available if the LSBit of this register is set. Not necessary to check this if ACCEL_DATA is read at a low frequency (a few times a second). 0xFFFF0060 WO LED LED[7:0]. Only the least significant 8 bits written to this location are used. LED[8] is used to show the divided clock. LED[15:9] shows PC[8:2]. PC[1:0] will a<code>lw</code>ays be 0 and hence not shown. 0xFFFF0064 RO DIP DIP switches. Only the least significant 16 bits read from this location are valid, corresponding to DIP switches [15:0]. 0xFFFF0068 RO PB PushButton switches. [2:0] \u2192\u00a0\u00a0BTNL, BTNC, BTNR. Only the least significant 3 bits read from this location are valid.\u00a0BTND is used as RESET and\u00a0BTNU is used as PAUSE. 0xFFFF0080 WO SEVENSEG 7-Segment LED display. The data written to this location will appear as an 8-digit hexadecimal number on the display. For the Basys 3 board, the two half-words will keep displaying in alternation. 0xFFFF00A0 RO CYCLECOUNT Cycles elapsed since the system came out of reset."},{"location":"rv_resources/rv_memmap/#table-1-memory-map-summary","title":"Table 1: Memory map summary","text":""},{"location":"rv_resources/rv_memmap/#a-note-on-data-memory","title":"A Note on Data Memory.","text":"<p>This kind of a data memory is slightly unrealistic and possible only in FPGAs.</p> <p>In embedded systems, the data memory has two parts - constants stored in a ROM/Flash (non-volatile) and variables stored in RAM.  Constants are available for reading without a prior writing (and can't normally be written).  Variables that are initialized are explicitly set to their initial value via writes (<code>sw</code> instructions). Variables should't be read (<code>lw</code>) without a prior write (<code>sw</code>) somewhere.</p> <p>In desktop systems, the data memory is typically all RAM, but has constants stored in read-only area that is initalised explicitly via writes (<code>sw</code>) and are not modified further. As with embedded systems, variables that are initialized are explicitly set to their initial value via writes (<code>sw</code> instructions). Variables should't be read (<code>lw</code>) without a prior write (<code>sw</code>) somewhere.</p> <p>In contrast, the FPGA-based systems often have a more flexible memory architecture*, allowing for RAM to be used like ROM, i.e., variables are auto-initialised - can be read without prior writes, but can also be modified.</p> <p>*At least the way it is used in our case, which necessitates the memory to be small and implemented using block or distributed RAMs available within the FPGA fabric and initialised using GSR.</p>"},{"location":"rv_resources/rv_memmap/#sizes-of-various-segments-base-addresses-and-peripheral-address-offsets","title":"Sizes of various segments, base addresses, and peripheral address offsets.","text":"<p>The RARS default memory configuration is as follows.</p> <ul> <li><code>IROM_BASE</code> = 0x00400000. This should be the same as the <code>.txt</code> address based on the Memory Configuration set in the assembler/linker, <code>Wrapper.v</code> and the PC default value as well as reset value in <code>ProgramCounter.v</code></li> <li><code>DMEM_BASE</code> = 0x10010000. This should be the same as the <code>.data</code> address based on the Memory Configuration set in the assembler/linker, <code>Wrapper.v</code>, C program.</li> <li><code>MMIO_BASE</code> = 0xFFFFF0000. This should be the same as the <code>.mmio</code> address based on the Memory Configuration set in the assembler/linker, <code>Wrapper.v</code>, C program.</li> </ul> <p>It is possible to change the configuration to others supported by RARS, such as compact with <code>.txt</code> at 0. MMIO base can be changed freely in any configuration, though if you need to use RARS simulated peripherals, it to be the default value.</p> <p>Instruction and data memory sizes can be bigger than 128 words. Be mindful of the potentially increased synthesis time though, especially if not using synch read (block RAM).</p> <p><code>DMEM_DEPTH_BITS</code> = 9. <code>DMEM_SIZE</code> = 2**<code>DMEM_DEPTH_BITS</code> = 0x200 = 512 bytes = 128 words by default. Changing this will need changes to <code>Wrapper.v</code>. Set <code>STACK_INIT</code> in C / asm program (via <code>.align</code> in asm, via <code>DMEM_SIZE</code>) in C.</p> <p><code>IROM_DEPTH_BITS</code> = 9. Changing this will need changes to <code>Wrapper.v</code>.</p>"},{"location":"rv_resources/rv_memmap/#endianness","title":"Endianness","text":"<p>The instruction and data memory are WORD addressable (NOT byte-addressable) for our labs. =&gt; Endianness doesn't matter for our hardware. Endianness matters only when each byte in the memory has an address, but we read/write one word (4 bytes) in one go.</p> <p>For example, if we store two words 0xABCD1234 and 0xEF567890 in the memory starting at the address 0x10010000, the two words will be stored at word addresses 0x10010000 and 0x10010004 respectively. In a system with a little-endian processor like RISC-V, the byte address 0x10010000 will have the content 0x34, byte address 0x10010001 will have the content 0x12, byte address 0x10010003 will have the content 0xAB, byte address 0x10010004 will have the content 0x90, byte address 0x10010007 will have the content 0xEF.</p> <p>In CG3207 labs, we use a system that cannot deal with byte addresses such as 0x10010001 and 0x10010002*. We can only send word addresses (addresses which are multiples of 4), i.e., like 0x10010000 and 0x10010004, and get the corresponding 32-bit contents. Hence, for our hardware, endianness doesn't matter*.</p> <p>*Unless you explicitly enable it by adding support for <code>lb</code>/<code>lbu</code>/<code>lh</code>/<code>lhu</code>/<code>sb</code>/<code>sh</code> - which is optional, and for later assignments.</p>"},{"location":"rv_resources/rv_programming/","title":"RISC-V Programming","text":"<p>Use RARS assembler / simulator which can be downloaded from their GitHub repository. This requires Java to be installed in your system; Java 8 is available here.</p> <p>The .jar program can be run by double-clicking it. It is portable across operating systems and needs no installation. It is a very simple and easy to use application. Linux users may need to use <code>java -jar filename.jar</code> - note the <code>-jar</code> option required to run a Java archive. </p> <p>You can use RISC-V assembly sample to get started. Download it, and open with RARS - File &gt; Open. Note : RARS assumes that SP(x2) and GP(x3) are initialized to 0x3ffc and 0x1800 respectively, and other registers are initialized to 0s. In the register file provided in the templates, only register zero (x0) is guaranteed to be 0, and others are uninitialized. You need to write a value to all registers other than x0 before you read them.</p> <p>Settings &gt; Memory Configuration &gt; Make sure Default is selected &gt; Apply and Close. It is also possible to select other configurations such as Compact, Text at Address 0, but needs appropriate changes in your Wrapper, ProgramCounter, and C program.</p> <p>Write/modify the code as necessary. You may want to look at these pages -\u00a0RARS Supported Instructions,\u00a0Assembly Directives.</p> <p>Run &gt; Assemble.</p> <p>Debug and see if the program runs as intended. The standard debugging options are available. You can single step, run until a breakpoint (breakpoints are set using the checkboxes next to assembled code), backstep (a cool feature which not many simulators support), pause, stop, reset.</p> <p>File &gt; Dump Memory. You can also do so by clicking the button in the toolbar as shown below. First, select the .text memory segment. Save it as Hexadecimal text with the name AA_IROM.mem. This is the instruction memory.</p> <p></p> <p>Do the same thing with .data too, and save it as AA_DMEM.mem, unless your program doesn't use any non-immediate constants / initialised variables at all. This is the data memory.</p> <p>Some of the useful RARS controls and tiles are highlighted below. </p>"},{"location":"rv_resources/using_compiled_code/","title":"Using Compiled Code","text":"<p>You can use the .C file in the Assignment 2 Optional Stuff folder as a sample. The corresponding .asm is also provided for reference. Please make sure you read the comments in the .C and .asm files.</p> <p>Please note some other points below.</p> <ul> <li>To the extent possible, it is a good idea to test your algorithms (e.g., masking and shifts to deal with bytes within a word.) in a standard C compiler, making appropriate changes (e.g., <code>printf()</code> and <code>scanf()</code>/hardcoding to simulate actual system input and output) to run in a desktop environment.</li> <li>Follow the Godbolt settings as shown. Ok to use a different/newer non-trunk version.</li> <li>The default Godbolt language maybe C++, change it to C. C++ compiler does stuff like name mangling which we can do without.</li> <li>Clang produces more comprehensible code than GCC, though sometimes at the expense of increased code size.</li> <li>In fact, GCC with <code>-Os -fwhole-program</code> can produce very optimised code with a flattened hierarchy (function calls removed), but can be pretty hard to make sense of. This can be useful if your processor does not support <code>jal</code> fully and <code>jalr</code> yet. In any case, do not use the trunk version of GCC.</li> <li>Do not use library functions such as <code>printf()</code>.\u00a0If need be, implement your own, simple versions of these functions.</li> <li>Make sure that only those instructions supported by your processor are generated. Check in the RARS execute window for actual instructions.</li> <li>Typically, the only essential change needed for the assembly code generated by Godbolt/Clang is to have a .data inserted just before the data declarations.</li> <li>Check the actual number of instructions (not lines of code as some instructions are pseudoinstructions). Make sure the size is set in Wrapper <code>IROM_DEPTH_BITS</code> as appropriate. e.g., should be 10 if the number of instructions is &gt;128 and &lt;=255.</li> <li><code>DMEM_DEPTH_BITS</code> should also be changed as appropriate, if you need more memory such as what you will need when you load images. <code>STACK_INIT</code> in your C source code should also be modified to correspond to this.</li> <li>Stack pointer is set to point to the top of DMEM initially (<code>STACK_INIT</code>). The stack is full-descending, so the first value is pushed to <code>STACK_INIT-4</code>.</li> <li>In the example C code (in the repo above), this is done via inline assembly. Alternatives are<ul> <li>Insert an assembly statement <code>la sp, STACK_INIT</code> as the first line in your assembly code <code>.text</code> section.</li> <li>Hard-code <code>RegBank[5'b00010]</code> initialization value to <code>STACK_INIT</code> via an <code>initial</code> block in <code>RegFile.v</code>. Of course, <code>STACK_INIT</code> should have a proper value via a <code>.equ</code> or be passed as a parameter to the <code>RegFile</code> module.</li> </ul> </li> <li>Make sure the correct memory config is selected in RARS.</li> <li>Pitfall of using larger instruction and/or data memory : your maximum clock frequency usually suffers. Bigger = slower is a fundamental law of nature that is not easy to work around.</li> <li>The first few instructions that save Callee saved registers to the stack can be deleted safely - do a sanity check to see if this is really the case nevertheless. There is no caller for <code>main()</code>.</li> <li>Make sure the main function code is at the beginning. Some compilers such as GCC may put this in the end, in which case you need to rearrange the functions in assembly. Our absolute bare-metal system does not have a linker/loader/startup code to start at the main if it is not in the beginning.</li> <li>Simulate the code in RARS.</li> <li>When using memory-mapped input peripherals, the corresponding address location should be modified just before the corresponding <code>lw</code> is executed to simulate the data coming in from peripherals.</li> <li>If you are using the counter peripheral for delay, you might want to use a smaller delay for simulation and change the code to a bigger value later. This can be changed in C code or directly in assembly (likely <code>lui</code>).</li> <li>Though you can't see OLED output, it is fairly easy to check the row, column, pixel colour, and pixel write signals and get a sense.</li> <li>Export the instruction and data memory as hexadecimal text, overwriting the <code>AA_IROM.mem</code> and <code>AA_DMEM.mem</code> that are added to the Vivado project.</li> <li>Simulate in HDL behavioral sim, after changing the <code>test_Wrapper</code> to give stimuli according to the inputs expected by your C/assembly program. Synthesize and do a post-synthesis simulation as well.</li> <li>Finally, run immplementation and generate bitstream. Fingers crossed :)</li> </ul>"}]}