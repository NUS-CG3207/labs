# Assignment 4: (Near) Complete Processor + Pipelining + Bells + Whistles

!!! success "Final"
    This page is now final. Updates will be minimal, and will be <span style="color: brown;">highlighted</span>. 

!!! info
    Assignment 4 involves **2 compulsory tasks** and the rest is **open-ended.**

    Demonstrate Post-synthesis simulation **AND** FPGA hardware incorporating all the mandatory and open-ended parts. Use a single assembly program that can be entirely compiler-generated, entirely handcrafted, or a combination of the two. Let your imagination run wild!

## Task 1: Implementing the remaining instructions for RV32I [5 points]

Add support for the following previously unsupported instructions/features mentioned below. They are pretty easy to add at this point and will allow you to run almost all the code generated by a compiler. Please see [Using Compiled Code](../../../rv_resources/using_compiled_code/) page for more info. However, using hand-coded assembly is perfectly fine too.

There is no need to try and craft a program specifically to demonstrate everything below, unlike in the previous labs. The only requirement is to have at least one function call in your program, which will cause `jal` (`call`) and `jalr` (`ret`) to be emitted by the compiler, unless you do a *whole program optimization* with GCC.

The instructions required are:

* DP instructions: `xor`, `xori`, `slt`, `sltu`, `slti`, `sltiu`, `slli`, `srli`, `srai`.
* Branch instructions: `blt`, `bge`, `bltu`, `bgeu`, `jal` (with support for linking: i.e. `rd = PC + 4`), `jalr`. 
* Multiply (M) instructions: `mulh`, `mulhu`, `div`, `rem`, `remu`. ***`mulhsu` is NOT a requirement***, as it requires some additional effort. `mulhsu` can be avoided in the compiler-generated code by avoiding signed x unsigned multiplications.

Support for byte and half-word load / store is NOT a basic requirement. They can be mostly avoided by using only `int`s in your program. However, incorporating them can lead to easier to write and more efficient programs, especially when using byte-oriented peripherals such as the UART console, 8-bit images with OLED, etc.

## Task 2: Pipelining our CPU [10 points]

Implement basic pipelining. Hazard hardware is optional and will count as an open-ended enhancement if done, but it is not counted for the compulsory task points. Pipelining should be done such that the processor supports all the requirements for Assignment 2, Assignment 3, and the additional instructions / features mentioned in Assignment 4 Compulsory Task 1 above.

As long as your code works after inserting sufficient `nop`s, this task requirement can be satisfied. If you have full hazard hardware, of course, `nop`s are unnecessary.

??? tip "Tips for implementing pipelining"

    * The WE of the PC given in the templates is active high, while the one given in the pipelined design (Chapter 6) is active low. You might want to change the PC WE in the templates to active low to be consistent.
    * Even though the pipeline registers are shown as big registers storing a lot of stuff, each data stored can be thought of as being in a separate register. In other words, in your HDL code, you don't have to try and 'collect' all the bits to form a single register entity.

    #### Systematic procedure for Pipelining

    Follow these steps to implement pipelining.

    1. Start by inserting the appropriate suffixes (F/D/E/M/W) for each wire, port, register, and signal. Refer to slide 11 of Chapter 6 for this. For every signal that goes through multiple pipeline stages, it will need to be split into two signals, separated by a pipeline register. **Note:** Generally, the signals going into every component will have the same suffix, since every component is part of one and only one pipeline stage. The exception to this is the register file, where `A3` and `WD3` (ARM) or `WD` (RISC-V).

    2. Make the appropriate datapath connection(s) for every signal going through a pipeline register. Some connections were made implicitly, such as ALUControl. These connections will need to be made explicitly. For RISC-V, a multiplexer must be inserted to select between `PC_F` and `PC_E`, controlled by `PCSrc_E`. Remember to change the datatype from `wire` to `reg` where necessary.

        * **Verilog**: Use a combinational always block with non-blocking assignments. For example:

        ``` verilog
        always @(*) begin
            ExtImm_E <= ExtImm_D;
        end
        ```

        in ARM.v or RV.v

        * **VHDL**: Use a concurrent statement (**NOT** inslude a clocked process for now). For example, `ExtImm_E <= ExtImm_D;` in ARM.vhd

    3. Verify that your design works **EXACTLY as it did previously**, without any changes to the assembly language program. We have NOT yet inferred any registers, so there should not be any pipelining going on (yet!). If something has broken, now is a good time to debug it.

    4. Now, we implement the pipeline registers.

        * **VHDL**: Move all the signals that are supposed to go through a particular pipeline register into one clocked process in ARM/RISC-V architecture (everything in one big clocked process is fine too, but it is better to keep it in separate processes for better organization).
        * **Verilog**: Change the combinational `always @(*)` to `always @(posedge clk)`.

    5. Initialize all your signals and registers to zero. Add a condition that sets all these signals and registers to zero when RESET is asserted, and otherwise, assigns the RHS to the LHS at the clock edge.

    6. Modify the Register file slightly, to read the clock at negative edges as follows. updated since 2024.
    <span style="color: brown;">Alternatively, you can leave it as posedge clk, and insert 3 `nop`s later instead of 2.</span>

        * **VHDL**: `CLK'event and CLK='1'` becomes `CLK'event and CLK='0'`.
        * **Verilog**: `always @(posedge clk)` becomes `always @(negedge clk)`.

    7. Your processor should now be pipelined, your old program may not work as it did. You will need to add `nop`s wherever there is any kind of hazard, to avoid these. For a start, just insert nops such that each pair of instructions having a data hazard is spaced by at least 2 instructions, for example, insert 2 nops if the two instructions are consecutive (or 3 if using the same clock edge). After each branch, insert 2 nops (or more if necessary, depending on which stage the branch is taken).

    8. Verify that your design works as it used to (it will just be slower because of all the nops).

    For hazard resolution hardware (not a basic requirement), follow the design in Chapter 5. Do it systematically and incrementally, one hazard at a time, and testing at each step.

??? tip "Increasing the clock speed"

    Now that you have pipelined your processor, you might be able to run it without any clock division, at the full 100 MHz, especially if your program memory and data memory are small. Change `CLK_DIV_BITS` to test if this is the case.

    However, note that even with the standard 5-stage pipeline, 100 MHz may not always be achievable, especially if your memory size is large.
    Up to ~430 MHz is possible, though unlikely with a 5-stage pipeline. To increase the clock beyond 100 MHz, you will need to make use of the FPGA's built-in clocking resource called MMCM (which uses phase-locked loops). This can be configured using a clocking wizard (Google for more info).

    Tips for faster clock speeds:
    
    * Identify the bottleneck by looking at that timing report.
    * Use smaller memories.
    * For larger memories, use block ram templates, and allow at least 2 clock edges, and maybe even 3 for a read. This, of course, is a major design change as the pipeline is no longer 5-stage.
    * Use a hierarchy of memories.
    * If the bottleneck is the execute stage, try to make it shorter by moving the PC logic to the M stage.

    Now, how do we know what frequency it can run at? You do synthesis and then implementation, and see the warnings. You'll get a critical warning that some timing constraints are not met if the frequency you set cannot be obtained. If you get this warning, the functionality is not reliable even if it runs on the board.

## Task 3: Open-ended Enhancement [10 points]

This is the fun part - you get 10 points for Assignment 4 for implementing performance enhancements of your choice. There is no fixed requirement to get these points, and while we suggest some enhancements below, it doesn't mean you need to implement all (or any!) of these. Just one significant performance enhancement will suffice, and this need not be limited to the ones we have listed.

??? tip "Idea: Hazard hardware"

    This is somewhat low-hanging fruit. After implementing simple pipelining, you'll probably get very annoyed, very quickly, by having to put `nop`s in the correct places. And this is before you make a mistake and spend hours debugging a bug caused by too few nops!

    You may choose to implement something simple that just stalls the processor, or perhaps something more interesting that forwards data when necessary. The complexity of your implementation will decide how well you score. 

??? tip "Idea: Additional instructions"

    You may choose to implement some additional instructions for your processor for your enhancement, or features of instructions that have not been fully implemented. The score you get for this will depend on how much additional logic you need to add for these features.

    === "Suggestions for RISC-V"

        #### RV: Implement half-word/byte load and store
    
        You might want to add support for byte and half-word load and store: `lb`, `lh`, `lbu`, `lhu`, `sb`, `sbu`. This can be useful for data memory, all read-only peripherals that have meaningful bytes/half-words, and for 7-segment display.

        `ReadData_in` is the whole word that contains the word/half-word/byte you want.
        You need to extract what you want, with a sign/zero(`u`) extension as required by the instruction.
        For example, when running `lbu` (load byte unsigned) instruction, if the last 2 bits of the address is `2'b01`, and the address location specified in the instruction has `8'hAB`, `ReadData_in` is `32'hxxxxABxx`. `ReadData`, the word to be written into the destination register is `32'h000000AB` (0s as MSBs as it is `lbu`).  
        For `lb`, `ReadData_in[15]` should be replicated to the 24 MSBs. You have to do this conversion.
        This is better done in the W stage in a pipelined processor.

        `WriteData_out` is a word, with word/byte/half-word aligned to where you wish to write it to within the word. The `MemWrite_out` bits of every byte to be modified should be 1. For example, when running `sb` (store byte) instruction, if the last 2 bits of the address is `2'b10` and the byte to be written is `8'hAB` (or `32'b000000AB`), `WriteData_out` should be `32'hxxABxxxx` and `MemWrite_out` should be `4'h0100`.You have to do this conversion.  
        Another example: when running `sh` (store halfword), if the last 2 bits of the address is `2'b10` and the half-word to be written is `16'hABCD` (or `32'h0000ABCD`), `WriteData_out` should be `32'hABCDxxxx` and `MemWrite_out` should be `4'h1100`. You have to do this conversion.

        CAUTION: Unaligned data reads and writes are NOT supported.
        If the instruction is `lh`/`lhu`/`sh` (load/store halfword), the data memory address should be divisible by 2 (the last bit should be 0)
        If the instruction is `lw`/`sw`, the data memory address should be divisible by 4 (the last two bits should be 0s)

        Please read the relevant comments in Wrapper.v carefully.

        Potential enhancement: Unaligned requests can be detected and used to generate interrupts by editing the wrapper. This interrupt could be used to do a software emulation of unaligned access via aligned access.

        #### RV: Implement ISA extensions 
        
        See the [RISC-V Specification](https://riscv.org/wp-content/uploads/2019/12/riscv-spec-20191213.pdf) for ideas. Floating-point, vector and cryptography are potentially interesting ISA extensions. 

    === "Suggestions for ARM"

        #### ARM: Implement more DP instructions

        * Implement all 16 Data Processing instructions. See Section "A3.4 Data processing instructions" in page A3-9 to A3-11 (page 75) of ARM [Architecture Reference Manual](https://canvas.nus.edu.sg/courses/62251/files/folder/Lab%20Resources?preview=4733362) for the details of the instructions. Page A3-11 has links to Sections 4.xx, where the instruction behavior is explained in more detail. Make sure you look at the ARM (32-bit) instructions, not Thumb (16-bit) instructions.
        * It mainly involves modifying the ALU and the ALU Decoder.
        * The C flag has to be an output from the CondLogic component/module, to act as an input for the ALU component/module (to support ADC instruction).
        * Implement it efficiently, hopefully without additional adders.
        * Support the additional multiplication instructions like `SMULL` and `UMULL`. There is not much point in implementing `SMLAL` and `UMLAL` since we already cannibalized the `MLA` instruction for division.
        * Support other instructions like `SWP` and `BL`.
        * Support other variants of existing instructions such as pre-indexed and post-indexed `LDR`/`STR`, Register Shifted Register Src2, `MUL` setting `Z` and `N` flags, etc.
        * Support Src2 for DP instructions with rotated immediates.
        * You can use the same shifter unit that we have used so far. Just make the appropriate connections.
        * This will need a 32-bit mux at the shifter input, a 1-bit mux for `Shamt5[0]` (which is '0' when _rot_ is used), as well as a 2-bit mux for sh (which is "11" for immediate Src2) - all the muxes can be controlled using the same control signal.
        * An alternative (more hardware efficient) is to move the shifter after the multiplexer controlled by `ALUSrc` (i.e., to just before SrcB of the ALU), and you can continue to use the same `ALUSrc` control signal. This will eliminate the need for a 32-bit multiplexer. However, you will need a 5-bit multiplexer for Shamt5, with a 2-bit control signal - select `Shamt5` for register Src2, (`Shamt5[4:1], 0`) for immediate Src2 and `00000` for all others. A 2-bit mux for sh will be required too, which selects "11" for immediate Src2, sh for register Src2, and either for all others (as the shift amount is zero for others anyway).
        * Your shifter could be modified to generate a carry ('C') based on the last bit that is shifted out (`shifter_carry_out`). This can be used to set the carry flag for instructions such as `MOVS`, `ANDS`, `ORRS`, etc. (see ARM reference manual for the explanation of `MOVS`, etc.).
        * This will require `FlagW` to be used differently (now that 'C' and 'V' are not always written together).
        * Effective 'C' will be instruction-dependent - need more logic to channel the appropriate carry into the input of 'C' flipflop/register. This logic can be inside the ALU (in which case the carry from the shifter will have to be an input to the ALU) or in the main ARM module.

        #### Tips

        * You may require additional read/write ports for the register file. You could also use micro-operations to avoid the need for more than 2 read ports / more than two write ports for some of the instructions - you will need additional logic to write results one by one over two cycles while PC is stalled. For example, for `SMULL`, `UMULL` etc, you can have an internal register (which is not in the visible register set) for storing the second word, to be written in the second cycle. You will also need to generate two sets of control signals - one for the first cycle and one for the second cycle. A multiplexer is required to select one of the two sets of control signals, which are passed to the E pipeline register over successive clock cycles.
        * You don't have to worry about how xPSR is dealt with in the special case of Rd=R15, as mentioned in the manual.
        * Note that when I bit of the instruction is 0, and bits 7 and 4 of the instruction are both 1's, the instruction is not a usual DP instruction (could be `MUL`, etc.).
        * You can modify the ARM processor to work even for `LDR PC,..` without that much of an effort. If `LDR` with PC as destination needs to be supported, we need to create a separate signal `PCWriteLDR` specifically for this case. `PCWriteLDRM + PCWriteLDRW` should stall D and Flush E., in addition to `PCSrcE` flushing D and E (effectively, we will be flushing 4 instructions). You will need to retain the multiplexer as in the original circuit to enable the result read from the memory to go into the PC. So essentially, you will have 2 multiplexers for PC input - one as in the original branch, and one for early BTA.
        * Forwarding data from W to D will allow you to write the register file at the positive edge, which will most likely reduce your critical path and improve the frequency at which your processor can operate.

??? tip "Idea: Exception handling and interrupt support"

    You can implement some simple interrupt handling. There is no need to conform to the RISC-V interrupt architecture.

    External interrupt generation logic can be done inside the wrapper fairly easily. For example, if you want an interrupt to be raised when any of the pushbuttons are pressed, you can do interrupt = `PB[3] | PB[2] | PB[1] | PB[0]`. This interrupt can then be fed into ARM/RV module from the wrapper.

    Other possible exception/interrupt sources are:

    * other peripherals - e.g., counter from Wrapper
    * invalid memory address - `bad_MEM_addr` from the address decoder of Wrapper
    * unaligned address - easy to detect in Wrapper or RV. The additional instructions page has some info on it
    * illegal instruction - from your instruction decoder
    * division by zero - from MCycle


    Some other tips:

    * You can have a hardcoded exception handler address input to the multiplexer controlling the PC input. The interrupt input itself can be used as (part of the) multiplexer select input.
    *   You can write your interrupt service routine in your assembly code, figure out the starting address, and use this value as a hardcoded input to the mux. An alternative is to decide on a fixed handler address, and fill up spaces/nops in your code until the handler starts address. For example, if you fix the handler starting address to be 0x100 and your 'main' program contains 30 instructions, you will need to add 34 nops before the first instruction in the handler code so that handler code will indeed be at 0x100.
    *   ARM: You should also have some mechanism to save `PC+4` into a register (say, `LR` in ARM) and to restore it when the handler has finished (use `MOV PC, LR` to return from the handler).
    *  RISC-V: The address of the instruction that caused the exception/ that was about to be executed when an interrupt came in is saved into *epc*^ (exception program counter, and not `ra`). Since we aren't aiming for compliance, saving automatically to another general-purpose register that isn't used in your program is an option too. Saving to `ra` can be problematic when you have function calls as `ra` gets overwritten. You can then use `jalr` aka `jr` to return from an interrupt. 
    ^ Note that *epc* is not a register that cannot be used like a general-purpose register. You need `csrr` to move its content to a general-purpose register.
    *   If you wish to have vectored interrupts, you need to associate a number with each interrupt. You need a table/ROM with the starting addresses, which will be indexed by the interrupt number. The output of this ROM is to be fed into the PC multiplexer. The PC multiplexer control signal can be the logical OR of all the interrupt lines.

??? tip "Idea: Branch prediction"
    
    Branch prediction is a very cool feature you can implement. There are many ways to approach this; a simple scheme is explored in the lecture. More complex and advanced ones are out there, but we will not teach you about them; they're for you to discover for yourself. 

    Do not be afraid to go and read some research papers on branch prediction schemes. Trying to implement something from a paper that has been published can be a very rewarding and educational exercise. 

??? tip "Idea: Use other hardware peripherals"

    This is not an improvement in and of itself; however, implementing more peripherals in your design might help you better demonstrate the features of your processor. 

    For example, the Nexys 4 has an onboard microphone - perhaps that can be used to demonstrate DSP capabilities? RGB LEDs? VGA port? USB host? The world is your oyster. 

    [Digilent's GitHub repository for the Nexys 4](https://github.com/Digilent/Nexys-4-DDR-OOB) contains some useful code to help implement these peripherals. 

## Design Instructions

* You are required to have your own, comprehensive programs to have a convincing demo.
* You may have to tweak the templates given in Assignment 2 for use in Assignment 4. Specifically, you will have to change the `ALUControl` to 4 bits for ARM, `PCSrc` and `ALUSrcA`/`B` width for RISC-V, etc.
* All 32-bit combinational arithmetic and logical operations have to be performed inside the ALU. *Exceptions*: `+` for calculating `PC+4`, `PC+8` (in ARM), multiplication, division, enhancements such as branch prediction. Pipeline hazard detection will require comparisons (for equality only) too, but they are on 5-bit values.
* In the ALU, DO NOT use additional `+` signs -> this could infer additional adders. The existing addition framework should be good enough.
* All operators are permitted on 32-bit values outside the ARM/RISC-V module. For example, you will have to do 32-bit comparisons in the wrapper for address decoding.
* Use of arithmetic operators:
    1. Do not use `*` operator. It is synthesizable, but in this course, we are implementing multi-cycle multiplication. `/` is not synthesizable, except on constants.
    2. All operators (including `**`, `*`, `/`, `sll`, `rem`, `mod` etc.) are allowed on constants (operations on constants are done at synthesis time, and will not infer any hardware).

## Submission Info
* Assignment 4 will be evaluated in **Week 12**. The presentation schedule can be found on Canvas.
* Include
    * **.v/vhd** files you have created/modified \[ RTL Sources, Testbench(es) \]
    * **.c/h** files used to generate assembly
    * **.bit** files
    * **.s/.asm** files (assembly programs)
    * **.ppt** file - 2 to 6 slides showing performance enhancement techniques you have implemented.

in an archive with the filename **GroupXX****\_Monday/Friday\_Lab4.zip** (replace XX with your group number) and upload it to Canvas. One submission per group is sufficient – if there are multiple submissions, the file with the latest timestamp will be taken as the final submission. ***Do not*** zip and upload the complete project folder – only those files mentioned above should be included. **The files should be the exact same files that you used for the demo.**
